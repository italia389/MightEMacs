.\" (c) Copyright 2017 Richard W. Marinelli    Ver. 8.5.0
.\"
.\" This work is licensed under the GNU General Public License (GPLv3).  To view a copy of this license, see the
.\" "License.txt" file included with this distribution or visit http://www.gnu.org/licenses/gpl-3.0.en.html.
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Bb \" Begin bullet item
.if t .sp .5v
.if n .sp
\fB*\fR
.in +.32i
.sp -1
..
.de Lb \" Begin list item
.if t .sp .5v
.if n .sp
\\$1
.in +.32i
.sp -1
..
.de Le \" End (bullet or) list item
.in
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.TH MEMACS-GUIDE 1 "2017-01-30" "memacs 8.5" "MightEMacs Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
memacs\-guide \- MightEMacs Tutorial and User's Guide
.SH "ABSTRACT"
This document describes the basics of editing files with MightEMacs and writing
scripts and macros to extend its features.  It also
contains instructive examples and information about its operation that is not available in the editor's help system.
.SH "EDITING A FILE"
The main purpose of any text editor is to edit files, so let's begin with a simple editing session.  You may
invoke MightEMacs with either the \fBmm\fR or \fBmemacs\fR command.  It can perform startup actions
as well (see memacs(1) for details).  Type the following at a shell prompt:
.Sp
.in +.4i
\&$ mm myscript.mm
.PP
A full-screen window opens displaying the first portion of the file.  If the file does not exist, the window will be
blank (as in this example).  The "mode line" in reverse video near the bottom of the screen contains basic information
about the editing session:
.Sp
.in +.4i
== MightEMacs 8.5.0 (Exact) [Memacs] == myscript == File: myscript.mm ===========
.PP
This says that we are running version 8.5.0 of the editor
with global mode \fIExact\fR and buffer mode \fIMemacs\fR enabled
(the latter of which was activated by the \fIsetLangMode\fR macro in site startup file "memacs.mm").  The buffer name
is "myscript" (derived from the filename) and the file pathname is "myscript.mm".
.Sp
Type a few lines of text and notice that an asterisk appears at the beginning of the mode line in the second column.  This is an
indicator that the buffer has been modified.  To move the cursor around, use the arrow keys or press \fIC-f\fR (\fIforwChar\fR),
\fIC-b\fR (\fIbackChar\fR), \fIC-p\fR (\fIprevline\fR), or
\fIC-n\fR (\fInextline\fR).  You can also jump to the end of a line (\fIC-e\fR), the beginning (\fIC-a\fR), traverse a
line quickly in either direction (press \fIC-t\fR repeatedly), move forward
a page (\fIC-v\fR), back a page (\fIC-z\fR), jump to the beginning of the buffer (\fIESC <\fR),
or to the end (\fIESC >\fR).
.Sp
Note that \fIC-b\fR means \fIcontrol\fR + \fIb\fR; that is, hold the "control" key down and press the "b" key.  On the
other hand, \fIESC <\fR means press the \fIesc\fR key, let go, then press the \fI<\fR key.  The \fIesc\fR key is the default
"meta prefix", which was entered on old keyboards
by holding down the \fImeta\fR key while pressing another key.  Although modern
keyboards often have another key that can be substituted for the \fImeta\fR key (like \fIalt\fR), MightEMacs does not
currently support this for portability reasons,
so the \fIesc\fR key is used instead, as a separate keystroke.  Note that meta key bindings such as
\fIESC k\fR will be shown in the editor as \fIM-k\fR in keeping with the old tradition,
where the "M" stands for "meta".  However, they will be shown in this document as \fIESC k\fR for clarity.
.Sp
Let's save our changes.  Press \fIC-x C-s\fR (\fIsaveFile\fR).
The asterisk changes back to "=" and you get some feedback in the "message line" at the bottom of the screen.
.Sp
Now let's make a few more changes, save the file again, and exit the editor.  Type a few characters so the buffer is
changed.  We can save the changes again by pressing \fIC-x C-s\fR and then exit by pressing
\fIC-x C-c\fR (\fIexit\fR).  However,
let's do this in one step instead.  Press \fIESC z\fR (\fIquickExit\fR).  The file is saved and we're back to the shell.
.SH "EDITING MULTIPLE FILES"
Multiple files can be edited in a couple of ways.  One way is to simply specify more than one file when invoking the editor.
For example, type the following:
.Sp
.in +.4i
\&$ mm Notes.txt myscript.mm
.PP
As before, a full-screen window opens displaying the first portion of the first file.  A buffer for the
second file was created also,
but it is currently in the background.  To bring it to the foreground, use the \fInextBuf\fR (\fIC-x ]\fR) or
\fIprevBuf\fR (\fIC-x [\fR) command.  Notice that the file is read at the same time.  (MightEMacs delays reading a
file if possible, until its buffer is selected.)  The \fIshowBuffers\fR command (\fIC-h b\fR)
displays all the buffers, which are always in alphabetical order.  Try that now.
The list is shown in a "pop-up" window.  Press \fI?\fR to see the commands
available in pop-up mode, which are all single keystrokes.  (These are a subset of the ones used by the "less" file
viewer.)  Press \fIq\fR or \fIESC\fR to get back to the edit window.  If you press a key other than a paging command,
it is "remembered" and used as the first keystroke of the next command after the pop-up window is dismissed.
.Sp
Now change some text in both buffers using the \fInextBuf\fR or \fIprevBuf\fR command to switch
between them.  Let's also rename one of the files.  Switch to the "myscript" buffer and type \fIC-x f\fR
(\fIsetBufFile\fR).  Enter a new filename of your choosing at the prompt (and notice that the buffer name is changed to match
the filename).  When this buffer is next saved, it will be
written to the new file.  If the file already exists, it will be overwritten.
.Sp
It is possible to save the changes in both buffers at once by specifying a numeric prefix (explained below)
to the \fIsaveFile\fR command.  Enter \fIC-u C-x C-s\fR to do this.  Notice that the name of each saved file is
displayed briefly on the message line.
.Sp
Let's open one more file in this editing session, say "src/main.c".
However, we'll have to create the subdirectory first.  To do that, we'll use the \fIshellCmd\fR
command.  Press \fIC-x !\fR.  At the "> " prompt, type "mkdir src" and \fIreturn\fR, then press the space bar to dismiss the
"[End]" prompt.
.Sp
Now we're ready to open our C file, which is done with the \fIfindFile\fR command.  Press \fIC-x C-f\fR.  At the prompt,
enter "src/main.c".  MightEMacs creates a new empty buffer for the file and switches to
it.  Note that the file has not yet been created
on disk (and if you exited the editor at this point without making any changes to the buffer, it wouldn't be).  Note also
that the mode line now shows the \fIC\fR buffer mode, which enables automatic indentation and fence matching as you type
your C code.
.Sp
Go ahead and enter some code if you wish.  You may also switch to the other buffers and edit those as well
by pressing \fIC-x [\fR or \fIC-x ]\fR as before, or by selecting a buffer directly (by name) with the
\fIselectBuf\fR (\fIC-x C-b\fR) command.  When you're finished, use the \fIquickExit\fR command again and see that all
the files are saved, and the pathnames are displayed as you return to the shell.
.Sp
Note that MightEMacs can edit text files containing \fICR-LF\fR, \fICR\fR, or \fINL\fR line delimiters.
The line delimiter is determined automatically (by default) when a file is read.  However,
regardless of which delimiter a file contains, all lines in a buffer are assumed to end with \fINL\fR.
MightEMacs remembers the real line delimiter for each buffer and writes it back to disk at the end of each line
when a file is saved.
.SH "KEY BINDINGS"
You have probably noticed that all of the commands we have introduced so far are invoked with either one or two keystrokes
(which may be preceded by a numeric prefix).  As it turns out, this is true for all MightEMacs commands.
No command "binding" is more than two keystrokes.  And if two are required, the first one is always
\fIESC\fR (\fImetaPrefix\fR), \fIC-x\fR (\fIprefix1\fR), \fIC-c\fR (\fIprefix2\fR), or \fIC-h\fR (\fIprefix3\fR).
Additionally, if the second keystroke is a letter, case is ignored.
A two-key binding is referred to as a "key sequence" and the first key is a "prefix key".
(The prefix keys can be rebound to keys other than the defaults shown above if desired.)
.Sp
It is also important to know that any key can be bound to a command or macro, including printable characters like letters
(each of which are bound separately by case), digits, and punctuation characters.
And when you type a key or key sequence, the command or macro that it is bound to is
executed.  By default, the printable keys
are bound to the "self insert" pseudo-command and thus, insert one copy of themselves into the text when typed.
(The one exception to this is the space bar, which is bound to the \fIspace\fR command.)
Non-printable keys and key sequences however, have no default action and will generate an error if typed when not bound
to anything.  Additionally, if an executed key or key sequence returns the value of the \fIfalse\fR
keyword, any running keyboard macro is stopped and "False return" is displayed on the message line.
(Keywords and keyboard macros are discussed later.)
.Sp
Generally, all key bindings used during an editing session are either built-in or are set in startup macros.  You can
change them interactively, however.  To create a key binding, enter \fIESC k\fR (\fIbindKey\fR), and to
delete one, enter \fIC-x C-k\fR (\fIunbindKey\fR).  To see all commands, macros, aliases,
and bindings, enter \fIC-h n\fR
(\fIshowBindings\fR).  Also, see the \fBWRITING SCRIPTS\fR section for the use and syntax of key bindings in coded
string form.
.SH "DISPLAY TERMINOLOGY"
We have introduced a few terms which have not been fully explained, so let's do that now.  In MightEMacs, the entire
terminal screen (usually a GUI window) is called the \fBscreen\fR.  A screen contains one or more \fBwindows\fR which
are created by splitting the screen vertically, into a top window and a bottom window.  This can be done multiple times to
create additional windows.  It is also possible to create multiple screens; however, all screens are stacked on top of
(overlay) each other so that only the frontmost one is visible at any time.  (Screens and windows are discussed in greater
detail in the \fBSCREENS\fR and \fBWINDOWS\fR sections.)

Windows display \fBbuffers\fR, which are containers that hold the text you are editing.  Buffers are usually associated with
files, but this is not required.  Multiple buffers may (and usually do) exist at the same time, some displayed in windows and
some in the background.  You switch to a buffer in a window in order to edit it.  You can also display the same buffer in
multiple windows, each with it's own "cursor" position.

Finally, every window (on every screen) maintains a current buffer position, which is where the cursor is when that window
is the current window.  This position is referred to as the \fBpoint\fR.  The point is saved with the buffer when a buffer is
put into the background, and restored again when it is redisplayed in a window.  Points also exist independently in windows;
that is, if one buffer is being displayed in multiple windows, each window will maintain it's own point for that buffer.
So in summary, the cursor on the screen is simply where the point is for the buffer in the current window.  We will refer to
the "point" hereafter in this document when referring to the current place in the text where editing operations will occur.
.SH "GETTING HELP"
You may be wondering by now what commands are available and what key(s) invoke them.  MightEMacs provides several ways to
get assistance.  To find out what a particular key or key sequence does, enter
\fIC-h ?\fR (\fIshowKey\fR).  Try
\fIshowKey\fR now.  Press \fIC-h ?\fR and at the prompt, type \fIC-x C-s\fR.
"'C-x C-s' -> saveFile - Save current buffer (if changed) to its associated file (or all changed buffers if n > 0)" is
displayed -- the command we used earlier.  Now type \fIC-_ C-h ? C-h\fR.  "'C-h' -> prefix3 - Prefix 3 key" is displayed.
If you supply a numeric prefix (explained in the next section)
to the \fIshowKey\fR command that is negative or zero, it reads a
single keystroke from the keyboard, as in this case where it displayed the binding for a prefix key.
.Sp
MightEMacs also provides informational displays via other "show" commands, which are all bound to a key sequence
that begins with \fIC-h\fR.  For example, as was mentioned in the previous section,
to see all commands, macros, aliases, and bindings, press \fIC-h n\fR
(\fIshowBindings\fR).  Scroll down to near the bottom of the list and notice that there are a few other "show" commands as well,
which you may want to try.
.Sp
A third way to get help is to use the \fIhelp\fR (\fIESC ?\fR) command.
Its default action is to either display a help file (a condensed summary of MightEMacs)
in a pop-up window, or display one of the MightEMacs man files, depending on what you enter at the prompt.  It can be
customized however, to do whatever you want it to do.
.SH "NUMERIC PREFIXES"
Much of the power of MightEMacs comes from the use of a numeric prefix with a command.  (The numeric prefix is
also referred to as the "n argument", mostly when writing scripts.)
A numeric prefix alters the default behavior of a command in some manner,
typically by specifying a direction (backward or forward) and/or a quantity (a number of lines or repetitions,
for example).  To illustrate this, open a file containing a few lines of text and we'll do some navigation.  Press
\fIESC f\fR (\fIforwWord\fR) and notice that the point moves one word forward.  Now press \fIC-u ESC f\fR.
The point moves two words forward.  Try \fIC-u 5 ESC f\fR or \fIC-_ C-_ C-n\fR and
see what happens.  You get the idea.
.Sp
To enter a numeric prefix to a command, press \fIC-u\fR and/or \fIC-_\fR one or more times.  The former key is for positive,
increasing values (in the sequence 2,0,3,4,5,...) and the latter key is for negative, decreasing values
(in the sequence -1,-2,-3,...).  Note that you can generate the negative prefix
by holding down the \fIcontrol\fR key and pressing \fI-\fR (dash) with or without the \fIshift\fR key.
You may also type digits directly, but only immediately
after the initial numeric prefix key.  Otherwise, the first digit will be taken as a "command" and inserted into the text.
You may also cancel the operation at any time by pressing \fIC-g\fR (\fIabort\fR).
.SH "CORE EDITING COMMANDS"
MightEMacs provides a core set of commands for performing common text editing operations in combination with a
numeric prefix.  Once these commands are mastered, you will be able to manipulate text quickly and easily.  The commands
are invoked using the following sequence of keys: (1), an optional numeric prefix; (2), an
optional copy, kill, or delete prefix key; and (3), a text "object" key.
The numeric prefix specifies a direction and quantity (with a default of one item forward).
The prefix key specifies the type of operation: copy (\fIC-c\fR for "copy"), kill (\fIC-h\fR for "homicide"),
or delete (no prefix).
And finally, the "object" key specifies the type of object to operate on: a word (\fIC-\\\fR), partial line (\fIC-k\fR),
line (\fIC-l\fR), region (\fIC-w\fR), or fenced region (\fI{\fR or \fI}\fR).
Copy and kill operations save the target text in the kill ring (for later "yanking"); deletes do not.  (See \fBMARKS\fR
below for an explanation of a "region".)
.Sp
So for example,
the following keys would kill the current line and the next line: \fIC-u C-h C-l\fR.  This translates
to "for 2 items forward", "kill", "line".  (Note that line operations always include an entire line plus the delimiter,
and the first line is always the current line.)  To \fBdelete\fR two lines forward instead, you would enter: \fIC-u C-l\fR.
Other examples:
.Sp
.in +.4i
\fIC-u 3 C-k\fR
.in +1.9i
.sp -1v
Delete text from the point up to, but not including the third line break.
.in
\fIC-_ C-\\\fR
.in +1.9i
.sp -1v
Delete previous word.
.in
\fIC-_ C-c C-\\\fR
.in +1.9i
.sp -1v
Copy previous word (without moving the point).
.in
\fIC-h {\fR
.in +1.9i
.sp -1v
Kill fenced region (point must be positioned on a \fI(\fR, \fI)\fR, \fI[\fR, \fI]\fR, \fI{\fR, \fI}\fR, \fI<\fR, or \fI>\fR
character first).
.in
\fIC-c C-w\fR
.in +1.9i
.sp -1v
Copy region (mark " " must have been previously set).
.in
\fIC-u C-u C-h C-k\fR
.in +1.9i
.sp -1v
Kill text from point to beginning of line (zero numeric prefix).
.PP
There is one exception to this rule: the \fIdeleteFencedText\fR command, which is \fIC-x {\fR or \fIC-x }\fR.
A left or
right brace would be inserted into the text if entered by itself, so the \fIC-x\fR prefix (for "exterminate") is needed.
.Sp
Also note that even though delete commands do not save the target text in the kill ring, the text \fBis\fR saved
in a special internal buffer, and the most recently deleted text can always be restored via the
\fIundelete\fR (\fIESC u\fR) command.
.SH "LINE BLOCKS AND LINE COMMANDS"
As discussed in the previous section, a numeric prefix may be used for the
\fIcopyLine\fR, \fIkillLine\fR, and \fIdeleteLine\fR commands to select a "block of contiguous lines" to operate on.
This method of selecting lines
is used by several other commands as well which operate on line blocks.  Each of these commands
use the numeric prefix to select one or more adjacent lines as follows:
.Sp
.in +.4i
n < 0		Select current line and n previous lines.
.sp +0
n > 0		Select current line and n - 1 following lines.
.sp +0
n == 0		Select all lines in current region.
.PP
The commands that operate on line blocks are as follows:
.Sp
.in +.4i
\fIcopyLine\fR		\fIC-c C-l\fR
.in +2.8i
.sp -1v
Copy line block to kill buffer.
.in
\fIdeleteLine\fR	\fIC-l\fR
.in +2.8i
.sp -1v
Delete line block.
.in
\fIdetabLine\fR		\fIC-x C-d\fR
.in +2.8i
.sp -1v
Change tabs to spaces in line block.
.in
\fIdupLine\fR		\fIESC d\fR
.in +2.8i
.sp -1v
Duplicate line block and place point at beginning of text of duplicated block.
.in
\fIentabLine\fR		\fIC-x C-e\fR
.in +2.8i
.sp -1v
Change spaces to tabs in line block.
.in
\fIjoinLines\fR		\fIESC C-j\fR
.in +2.8i
.sp -1v
Convert line block to single line with white space between lines replaced with a single space.
.in
\fIkillLine\fR		\fIC-h C-l\fR
.in +2.8i
.sp -1v
Delete line block and save to kill buffer.
.in
\fIlcLine\fR		\fIC-x l\fR
.in +2.8i
.sp -1v
Convert line block to lower case.
.in
\fItrimLine\fR		\fIC-x C-t\fR
.in +2.8i
.sp -1v
Trim white space from end of each line in line block.
.in
\fIucLine\fR		\fIC-x u\fR
.in +2.8i
.sp -1v
Convert line block to upper case.
.in
\fIwrapLine\fR		\fIESC RTN\fR
.in +2.8i
.sp -1v
Rewrap lines in line block.
.PP
Additionally, the \fIjoinLines0\fR, \fIwpJoinLines\fR, and \fIwpWrapLine\fR macros, which provide
additional features, also operate on line blocks.  See memacs-macros(1) for details.
.SH "MARKS"
During an editing session, you will often have the need to mark a "region" of text so that you can perform some operation on
it; for example, to delete or copy it so that you can insert it elsewhere.  You may also want to mark your place so you
can easily return to it later.  To do this, you set a "mark" at the current point location in the buffer,
which is a single printable character of your choosing (a letter, digit, or punctuation character).  The space character is
also included, and is used to delineate a region.  Whenever the space mark has been defined in a buffer,
a region always exists, and is defined as all the text between the point and that mark (which may be none, if the point is at
the mark).  Some commands operate only on regions (like \fIindentRegion\fR), and several will alternately
operate on the current region if a numeric prefix of zero is specified for the command.  As it turns out, the space mark is
always defined in a buffer (and cannot be deleted)
and so a region always exists.  When a buffer is created, the mark is set to be at "end of buffer".
.Sp
The marks commands are as follows:
.Sp
.in +.4i
\fIdeleteMark\fR	\fIC-x C-SPC\fR
.in +2.8i
.sp -1v
Delete a mark, or all marks if a numeric prefix is specified.
.in
\fIgotoMark\fR		\fIESC SPC\fR
.in +2.8i
.sp -1v
Go to a mark.  If a numeric prefix is specified, delete the mark after moving to it.
.in
\fImarkBuf\fR		\fIESC C-SPC\fR
.in +2.8i
.sp -1v
Mark the entire current buffer as the current region (presumably for a subsequent region command).
.in
\fIsetMark\fR		\fIC-SPC\fR
.in +2.8i
.sp -1v
Set a mark.  Default action is to set mark " " without prompting.  If a negative numeric prefix is specified, sets
mark "."; if a non-negative numeric prefix is specified, prompts for the mark to set.
.in
\fIshowMarks\fR		\fIC-h SPC\fR
.in +2.8i
.sp -1v
Shows all marks set in the current buffer in a pop-up window.
.in
\fIswapMark\fR		\fIC-x C-x\fR
.in +2.8i
.sp -1v
Swap point with a mark.  Obtains a mark in the same manner as \fIsetMark\fR.
.PP
For example, to indent a block of lines, set mark " " anywhere on the first (or last) line by pressing \fIC-SPC\fR, move
the point to the other end of the line block, then press \fIESC )\fR, optionally with a numeric prefix to specify the number
of tab stops.  To copy a block of lines to the kill ring instead, mark the block in the same mannner, then press
\fIC-u C-u C-c C-l\fR, which executes the \fIcopyLine\fR command with a numeric prefix of zero.  As a final example, to
save the point position and window framing at say, the beginning of a routine called "myfunc" which is currently being
displayed, press \fIC-u C-SPC\fR (setMark) and enter \fIm\fR (or some other character)
at the prompt.  You can then return to this exact location at any time (in any window displaying this buffer) with the same
window framing by pressing \fIESC SPC\fR and entering \fIm\fR again.  You can also move back and forth between the current
location and that mark by entering \fIC-u C-x C-x m\fR (\fIswapMark\fR).  Lastly, a shortcut for moving between two locations
is to set mark "." by pressing \fIC-_ C-SPC\fR, moving the point elsewhere, then pressing \fIC-_ C-x C-x\fR.
Each time you enter the latter key sequence, you will move to the other location in the buffer (mark ".").
.SH "KILL RING"
Whenever a text object is copied or killed, it is saved in the kill ring.  The kill ring is a 30-slot area of memory
which can hold any amount of text in each slot.  When a new kill occurs, previous kills are "pushed back" one position
(in a stack fashion) so that the most recent kill is always the first one to be retrieved.  The \fIyank\fR (\fIC-y\fR)
command is used to insert text from the kill ring into the text, at the current point position.
You should try this out and get a good feel for how it works.  It is a very handy feature.
.Sp
There are three other related
commands that you should know as well: \fIyankPop\fR (\fIESC y\fR), \fIcycleKillRing\fR (\fIC-x y\fR),
and \fIshowKillRing\fR (\fIC-h k\fR).  To yank the most recent kill, press \fIC-y\fR.  If you want a kill before that,
immediately press \fIESC y\fR (\fIyankPop\fR) one or more times.  Each time you execute the
\fIyankPop\fR command, the last inserted kill text
is replaced with the previous one.  It also cycles the kill ring so that the last kill inserted stays at the "top".
.Sp
You can also cycle the kill ring manually before yanking via the \fIcycleKillRing\fR command.
This is handy when you have two or more kills
and want to insert each one in a different place.  Move to the first location and insert the last kill first (\fIC-y\fR),
move to the next location, cycle the kill ring (\fIC-x y\fR), then insert the next one (\fIC-y\fR).
.Sp
Another way to do this is to use a negative n argument with \fIyank\fR to access older kills directly.  In the last example,
you could skip the cycle command and insert the next to last kill via \fIC-_ C-y\fR.
.Sp
Lastly, to see the kill ring at any time (in a pop-up window), enter \fIC-h k\fR.  The most recent kill is number
0, followed by -1, -2, etc.
.SH "POP-UP WINDOWS"
By now, you probably have a pretty good idea what pop-up windows are.  They are used extensively
by MightEMacs for many purposes, including "completions" which are explained next.  If you are still a little foggy
about them however, now would be a good time for a review.  You can use the \fIshowBindings\fR (\fIC-h n\fR)
command to display a pop-up window and figure out how to move around in it.  Remember that \fI?\fR displays the available
commands and \fIq\fR or \fIESC\fR exits.
.SH "COMPLETIONS"
MightEMacs provides a very useful feature called "completions".  With few exceptions, any time a command, alias, macro,
buffer name, file pathname, or variable name needs to be entered at a prompt, you can enter zero or more characters of the name
and press \fItab\fR to see the items that begin with those characters in a pop-up window.  This can be repeated as many
times as you like by adding or subtracting characters and pressing the tab key again.
You may also enter \fI?\fR to see the
matching items, the difference being that \fItab\fR will automatically extend the input string to the first character that
differs among the items, but \fI?\fR will not.  If only one item matches, then the
name is "completed" when the tab key is pressed and, depending on the operation,
either (1), the entire name is shown, waiting for you to press \fIreturn\fR to
continue; or (2), the entire name is displayed (briefly) and the operation is performed.
.Sp
For example, say you want to search for a file to edit.  You can use the \fIfindFile\fR command and look around.
Enter \fIC-x C-f\fR.  At the prompt, type part of a file path and hit \fItab\fR.  You should see matching filenames
in a pop-up window.  (If nothing matches the
characters you entered however, the window will be blank and you will hear an audible beep.)  You can see all the
files in the current directory by pressing the tab key immediately after the prompt.  You can also expand environmental
variables, your home directory, or any user's home directory by entering \fI$xxx/\fR, \fI~/\fR, or \fI~xxx/\fR, respectively.
.Sp
Note that if the pop-up window is being displayed, you must dismiss it first before you can type more characters.  Usually,
you can just begin typing; however, if the first character you type happens to be a window-navigation character (like \fIf\fR
for "next page"), it will be interpreted as such.  In this case, just press \fIESC\fR or \fIq\fR to dismiss the window first.
.SH "MODES"
MightEMacs provides two types of "modes" to activate features during the
editing session: \fBglobal\fR and \fBbuffer\fR.  Global modes apply to all buffers, whereas buffer
modes (as the name implies) apply only to the buffer in which they are activated.  Both types of modes are
displayed in the mode line at the bottom of each window.  Global modes are in parentheses "()" and buffer modes are in
brackets "[]".
.Sp
It is possible to activate a global mode but not display it.  This is controlled
by \fBshow\fR modes.  It is also possible to predefine buffer modes that all new buffers will be initialized with.  These
are the \fBdefault\fR modes.
.Sp
To see all available modes, use the \fIshowModes\fR command (\fIC-h o\fR), which will display all global and buffer
mode names and a brief description of each in a pop-up window.  The letter in parentheses or brackets at the beginning
of the description indicates whether the mode is a global or buffer type.
Modes are activated, toggled, or deactivated with the
four mode commands:
\fIalterGlobalMode\fR (\fIESC m\fR), \fIalterBufMode\fR (\fIC-x m\fR),
\fIalterShowMode\fR (\fIC-h m\fR), and \fIalterDefMode\fR (\fIC-c m\fR).
Each command will prompt for a mode name, then activate, toggle (the default), or deactivate it
for a positive, zero, or negative numeric argument.  A partial name may be entered followed by the tab key to perform
name completion.  You may also enter the minimum number of characters needed (ignoring case) to uniquely identify a name
and press \fIreturn\fR to select it.  For example, "rd" may be entered for the "RdOnly" buffer mode.
.SH "BUFFER COMMANDS"
All editing of text occurs in a buffer.  A buffer may or may not be attached to a file.  If it is, the filename will be
shown in the mode line of the window displaying the buffer.
The filename is completely independent of the buffer.  It may be changed at any time or
deleted.  It really only comes into play when an I/O operation is performed on the buffer, at which point it must exist
and be valid for the I/O operation to complete successfully.  As you may have guessed, MightEMacs opens a
file, performs I/O, and closes the file at the moment a file command is executed.  The file is not opened until then and is
closed immediately afterward.
.Sp
The \fIsetBufFile\fR (\fIC-x f\fR) command is used to associate a filename with the current buffer.  If you press
\fIreturn\fR or \fIC-k\fR at the prompt, the filename will be deleted.
.Sp
MightEMacs provides several other commands for working with buffers, which you may want to try out:
.Sp
.in +.4i
\fIclearBuf\fR		\fIC-x DEL\fR
.in +2.8i
.sp -1v
Delete all text from the current buffer and mark as unchanged.
.in
\fIdeleteBuf\fR		\fIC-x k\fR
.in +2.8i
.sp -1v
Delete a named buffer.
.in
\fIinsertBuf\fR		\fIC-x r\fR
.in +2.8i
.sp -1v
Insert a named buffer into the current buffer.
.in
\fIlastBuf\fR		\fIC-x \\\fR
.in +2.8i
.sp -1v
Switch back to last buffer exited from.
.in
\fInextBuf\fR		\fIC-x ]\fR
.in +2.8i
.sp -1v
Switch to the next (alphabetically higher) buffer.
.in
\fIprevBuf\fR		\fIC-x [\fR
.in +2.8i
.sp -1v
Switch to the previous (alphabetically lower) buffer.
.in
\fIscratchBuf\fR	\fIC-x s\fR
.in +2.8i
.sp -1v
Create a "scratch" buffer with a unique name and switch to it.
.in
\fIselectBuf\fR		\fIC-x C-b\fR
.in +2.8i
.sp -1v
Switch to a named buffer.
.in
\fIsetBufName\fR	\fIC-x b\fR
.in +2.8i
.sp -1v
Set the name of the current buffer (which cannot be null).
.in
\fItruncBuf\fR		\fIESC t\fR
.in +2.8i
.sp -1v
Truncate current buffer; that is, delete all text from the point to the end of the buffer.
.in
\fIunchangeBuf\fR	\fIESC ~\fR
.in +2.8i
.sp -1v
Mark the current buffer as unchanged.
.in
\fIxeqBuf\fR		\fIC-x x\fR
.in +2.8i
.sp -1v
Execute a named buffer as a macro.
.PP
There are two other buffer commands worth mentioning: \fInarrowBuf\fR (\fIC-x <\fR) and
\fIwidenBuf\fR (\fIC-x >\fR).  The \fInarrowBuf\fR command temporarily shrinks the current buffer to a block of
contiguous lines, which is determined by the numeric prefix.  When buffer "narrowing" is in effect, a "<" character is
displayed in the third column of the mode line.  Narrowing a buffer can be useful for performing editing operations on
a portion of it without affecting the excluded text; for example, when doing a search and replace, or running a keyboard
macro repeatedly until the "end" of the buffer is reached.  A buffer can remain narrowed for as long as you like and
edited normally, although you will not be able to access any of the hidden lines or marks while it is narrowed.  To restore it
(keeping any changes that were made), enter \fIC-x >\fR.
.SH "FILE COMMANDS"
In our examples thus far, we have used two file commands: \fIsaveFile\fR and \fIfindFile\fR.  There are a few
other file commands as well.  The file commands provide various ways to read and write files and manage their
associated buffers.  Here is the complete list:
.Sp
.in +.4i
\fIappendFile\fR	\fIC-x C-a\fR
.in +2.8i
.sp -1v
Prompt for a filename (waiting for \fIreturn\fR to be entered when completing the name),
append the current buffer to the given file, and attach the filename to the buffer.
.in
\fIfindFile\fR		\fIC-x C-f\fR
.in +2.8i
.sp -1v
Prompt for a filename (waiting for \fIreturn\fR to be entered when completing the name if the numeric prefix is 1)
and find the file.  Check pathnames associated with existing buffers first, then files on disk.  Switch to the existing buffer
if found; otherwise, create a buffer, switch to it, and read in the file from disk.
.in
\fIinsertFile\fR	\fIC-x C-i\fR
.in +2.8i
.sp -1v
Insert a file from disk into the current buffer before the current line.
.in
\fIreadFile\fR		\fIC-x C-r\fR
.in +2.8i
.sp -1v
Read a file from disk into the current buffer, replacing its contents, and mark the buffer as unchanged.
.in
\fIsaveFile\fR		\fIC-x C-s\fR
.in +2.8i
.sp -1v
Write the current buffer to its associated file, overwriting the file if it already exists.
.in
\fIviewFile\fR		\fIC-x C-v\fR
.in +2.8i
.sp -1v
Find a file in the same manner as the findFile command, but enable the 'rdonly' buffer mode also.
.in
\fIwriteFile\fR		\fIC-x C-w\fR
.in +2.8i
.sp -1v
Prompt for a filename (waiting for \fIreturn\fR to be entered when completing the name),
write the current buffer to the given file, and attach the filename to the buffer.
.in
\fIxeqFile\fR		\fIC-x /\fR
.in +2.8i
.sp -1v
Execute a file as a macro.
.PP
If an OS error occurs when reading or writing a file, the operation will be aborted and
an error message will be displayed in the message line.
.SH "APROPOS"
It is possible to search for names of commands, functions, or variables by using the apropos feature of the
\fIshowBindings\fR (\fIC-h n\fR), \fIshowFunctions\fR (\fIC-h f\fR), and \fIshowVariables\fR (\fIC-h v\fR)
commands.  To perform an apropos search, simply enter a numeric prefix to the command.  You will then be prompted for
a search string.  Any names that contain the string you enter will be displayed (ignoring case).
For example, to find all the "show" commands, enter \fIC-_ C-h n\fR and type "show" at the prompt.  (The numeric
argument must be negative to view the results in a pop-up window.  This is explained in more detail in the BUFFER RENDERING
section below.)
.Sp
You may also use the \fIapropos\fR (\fIESC a\fR) macro, which searches all three "show" lists and displays the results
in a single pop-up window.
.SH "SEARCHING AND REPLACING"
There is a group of commands for searching for a pattern in a buffer and optionally, replacing one or more occurrences of
the matching text with a string or another pattern.  MightEMacs
supports searching using regular expressions (REs) or plain text patterns.  Additionally, either type of search can be
case-sensitive or case-insensitive, and searching can be done either forward or backward.
The type of pattern matching is controlled by option characters appended to the pattern string (explained below),
and by two global modes: \fIExact\fR and
\fIRegexp\fR.  When enabled, the former mode specifies case-sensitive pattern matching and the latter specifies RE matching.
Either or both can be enabled or disabled at any time.
.Sp
The following regular expression pattern-matching metacharacters are supported:
.Sp
.in +.4i
\fB^\fR
.in +1.0i
.sp -1v
Match beginning of line (after a \fINL\fR character) or negate a character class.
.in
\fB$\fR
.in +1.0i
.sp -1v
Match end of line (before a \fINL\fR character).
.in
\fB\.\fR
.in +1.0i
.sp -1v
Match any character except \fINL\fR.
.in
\fB*\fR
.in +1.0i
.sp -1v
Match zero or more occurrences of the previous character or character class.
.in
\fB+\fR
.in +1.0i
.sp -1v
Match one or more occurrences of the previous character or character class.
.in
\fB?\fR
.in +1.0i
.sp -1v
Match zero or one occurrence of the previous character or character class, or specify closure modification.
.in
\fB{m,n}\fR
.in +1.0i
.sp -1v
Match a minimum of \fBm\fR and a maximum of \fBn\fR occurrences of the previous character or character class, where
\fBm\fR and \fBn\fR are unsigned integers.
\fBm\fR is required; however, \fBn\fR or \fB,\fR may be omitted.  In the \fB{m,}\fR form, \fBn\fR defaults
to an infinite value.  In the \fB{m}\fR form, exactly \fBm\fR occurrences must match.
.in
\fB[\fR
.in +1.0i
.sp -1v
Begin a character class definition.
.in
\fB]\fR
.in +1.0i
.sp -1v
End a character class definition.
.in
\fB(\fR
.in +1.0i
.sp -1v
Mark the beginning of a group.
.in
\fB)\fR
.in +1.0i
.sp -1v
Mark the end a group.
.PP
The \fB?\fR character is used for
"zero or one of the previous item" or as a modifier following itself, \fB*\fR, \fB+\fR, or \fB{m,n}\fR
meaning "as few as possible".
.Sp
The space character and some control characters may be specified with the \fB\\x\fR notation:
.Sp
.in +.4i
\fB\\s\fR
.in +1.0i
.sp -1v
Space character.
.in
\fB\\t\fR
.in +1.0i
.sp -1v
Tab character.
.in
\fB\\r\fR
.in +1.0i
.sp -1v
Carriage return.
.in
\fB\\n\fR
.in +1.0i
.sp -1v
Newline.
.in
\fB\\f\fR
.in +1.0i
.sp -1v
Form feed.
.PP
Special anchor and positional metacharacteers may be specified with the \fB\\x\fR notation also:
.Sp
.in +.4i
\fB\\A\fR
.in +1.0i
.sp -1v
Match beginning of string.
.in
\fB\\z\fR
.in +1.0i
.sp -1v
Match end of string.
.in
\fB\\Z\fR
.in +1.0i
.sp -1v
Match end of string, but just before any trailing \fINL\fR character if present.
.in
\fB\\b\fR
.in +1.0i
.sp -1v
Match a word boundary, as defined by the value of the $wordChars global variable.
.in
\fB\\B\fR
.in +1.0i
.sp -1v
Match a non-word boundary, as defined by the value of the $wordChars global variable.
.PP
Character classes \fB[]\fR may contain range(s) or be negated with a leading
\fB^\fR metacharacter; for example, "[a-zA-Z0-9_]" or "[^0-9]".
A few common character classes may be specified with the \fB\\x\fR notation as well:
.Sp
.in +.4i
\fB\\d\fR		[0\-9]
.in +3.0i
.sp -1v
Digit.
.in
\fB\\D\fR		[^0\-9]
.in +3.0i
.sp -1v
Non\-digit.
.in
\fB\\l\fR		[a\-zA\-Z]
.in +3.0i
.sp -1v
Letter.
.in
\fB\\L\fR		[^a\-zA\-Z]
.in +3.0i
.sp -1v
Non-letter.
.in
\fB\\s\fR		[ \\t\\r\\n\\f]
.in +3.0i
.sp -1v
Space character.
.in
\fB\\S\fR		[^ \\t\\r\\n\\f]
.in +3.0i
.sp -1v
Non-space character.
.in
\fB\\w\fR		[a-zA-Z0-9_]
.in +3.0i
.sp -1v
Word character, as defined by the $wordChars variable.
.in
\fB\\W\fR		[^a-zA-Z0-9_]
.in +3.0i
.sp -1v
Non-word character, as defined by the $wordChars variable.
.PP
Additionally, any of the \fB\\t\fR, \fB\\r\fR, \fB\\n\fR, or \fB\\f\fR control characters
and the \fB\\d\fR, \fB\\l\fR, \fB\\s\fR, or \fB\\w\fR
metacharacters may be specified inside a character class as combinations, such as "[\\l\\d]" to specify any letter or digit.
.Sp
Plain parentheses \fB(\fR and \fB)\fR are used for grouping and escaped versions
\fB\\(\fR and \fB\\)\fR are used to search for the literal characters.  Grouped match strings may be included in a replacement
pattern by specifying \fB\\n\fR, where n is a digit in the range 1-9 and refers to the nth group.  Groups are numbered in
sequence by the opening parenthesis in the search pattern, beginning at 1.
The entire matched string is represented by \fB\\0\fR or the \fB&\fR metacharacter.
.Sp
Lastly, a colon and one or more lowercase letters may be appended to any pattern to specify options, as follows:
.Sp
.in +.4i
\fBe\fR
.in +1.0i
.sp -1v
Exact pattern matching.  Case of letters is significant.
.in
\fBi\fR
.in +1.0i
.sp -1v
Ignore case.  Case of letters is not significant.
.in
\fBp\fR
.in +1.0i
.sp -1v
Plain text matching.  The pattern is matched literally.
.in
\fBr\fR
.in +1.0i
.sp -1v
Regexp matching.  The pattern is matched as a regular expression.
.in
\fBm\fR
.in +1.0i
.sp -1v
Multi-line mode.  When performing RE matching,
the \fB.\fR metacharacter and a negative character class \fB[^...]\fR will match a \fINL\fR,
which they do not by default (but only if, in the latter case, the character class does not contain a \fINL\fR).
.PP
.Sp
Pattern options always override the corresponding global modes.
For example, the pattern "abc.:ri" would be processed as a regular expression
and case would be ignored, whether or not the \fIExact\fR or \fIRegexp\fR global modes were enabled.  Whereas "abc.:e" would
cause case to be significant,
but would be processed as a regular expression if \fIRegexp\fR mode was enabled, and as plain text if not.
Also, to allow a pattern option string to be part of a pattern and avoid ambiguity when a pattern is interpreted, the
following rule is used: "If a pattern ends with a colon followed by one or more
valid option letters, and the colon is not the first character of the pattern, then everything preceding the colon is the
pattern.  In all other cases, the entire string is the pattern (with no options)."  So for example, the pattern
"abc:ri" would be interpreted as RE pattern /abc/i, "abc:r:p" would be interpreted as plain text pattern 'abc:r',
"abc::r" would be interpreted as RE pattern /abc:/, and "abc:rx" would be interpreted as plain text pattern 'abc:rx'
(because it contains invalid option letter \fBx\fR).
.Sp
The \fB|\fR and \fB{}\fR metacharacters are not currently supported, and the closure metacharacters \fB*\fR \fB+\fR \fB?\fR may
not be applied to a group.
.Sp
To search for a pattern, use the \fIsearchForw\fR (\fIC-s\fR) or \fIsearchBack\fR (\fIC-r\fR) command.  You will be prompted
to enter the pattern.  (The pattern is delimited by \fIESC\fR by default so that \fINL\fR can be entered as part of the
pattern.  This can be changed however, by setting the $searchDelim variable to \fINL\fR or a different delimiter key.)
Once a pattern has been set,
the \fIhuntForw\fR (\fIC-]\fR) and \fIhuntBack\fR (\fIC-^\fR) commands may be used in any combination
to search for the next occurrence.
The search pattern is saved in the $searchPat variable.
.Sp
To find and replace text, use the \fIreplace\fR (\fIESC r\fR) or \fIqueryReplace\fR (\fIESC q\fR) command.
To replace a fixed number of occurrences of a pattern, specify a numeric prefix to the \fIreplace\fR command; otherwise,
it will replace all occurrences from the point to the end of the buffer.  The \fIqueryReplace\fR command works like
\fIreplace\fR but prompts for an action to take each time a match is found.  You can enter \fI?\fR at the prompt to get a list.
Actions include: skipping to the next occurrence,
undoing the last replacement and reprompting at that location, stopping and returning to the starting point, and replacing
all remaining matches without prompting.  In all cases, either command will stop if a match is not found.  The replacement
pattern is saved in the $replacePat variable.
.Sp
There is one additional search and replace option: the \fIqueryReplaceAll\fR macro (\fIESC C-q\fR), which is loaded
from the site startup file "memacs.mm".  This macro performs a \fIqueryReplace\fR on every (visible) buffer in the current
editing session, pausing from one to the next to display results and give you the option to continue or quit.
Additionally, it can be preceded by the \fIgrepFiles\fR macro (\fIC-x C-g\fR), also loaded from
the site startup file), to open all files matching a shell glob pattern, or only those matching the shell pattern and also
containing a plain text (fgrep) or RE (egrep) pattern.  This gives you the ability to find files containing a pattern
and then doing a mass search and replace on those files in real time.  For the \fIgrepFiles\fR macro, use a non-negative
numeric prefix to perform an RE search (see memacs-macros(1) for details).
You may also leave the search pattern blank (by pressing \fIESC\fR at the prompt) to skip the
"grep" filtering.  Additionally, you may limit the buffers to search to just the ones found by \fIgrepFiles\fR by entering a
negative numeric prefix to the \fIqueryReplaceAll\fR macro.
.Sp
Note that pattern match and replacement operations may also be performed on buffer lines or arbitrary text via a script.
The \fI=~\fR and \fI!~\fR operators do RE comparisons, the \fIindex\fR function locates a plain text or RE pattern
in a string, and the \fIsub\fR
function performs search and replace on a string using the specified plain text or RE patterns.
.Sp
Note also that when pattern matching is performed with the \fI=~\fR operator, the \fIindex\fR function, or any of the search
and replace commands, the string and groups that are matched (whether in a buffer or a string) are available via
the \fImatch\fR function.
.SH "LINE WRAPPING"
MightEMacs provides the ability to wrap text, either automatically as you type, or all at once by
specifying a block of lines to operate on.  There is a function and two commands
for this: \fIwrapWord\fR, \fIwrapLine\fR (\fIESC RTN\fR), and \fIjoinLines\fR (\fIESC C-j\fR).
.Sp
By default, the \fIwrapper\fR macro (which is loaded
from the site startup file "memacs.mm" and calls the \fIwrapWord\fR function)
is used as the "wrap hook" and has no key binding.  It is called by the editor when
the "wrap" buffer mode is enabled and other conditions are met (see \fBHOOKS\fR below for more information).
The function moves the word at or just before the point to a new
line if possible, and deletes any white space that preceded it.  However, if no space character is found preceding the word,
it moves the point to the end of the line (by default) and starts a new line.  This behavior can be modified somewhat by
specifying a numeric prefix, which it uses as the left margin column instead of 0 (the default).  In this case,
it will only wrap words that are wholly at or beyond the left margin, and if no space character is found preceding the word,
it will search forward for a space character and break the line at that point if possible, instead of at the end of the line.
.Sp
The \fIwrapWord\fR function is intended to only be used indirectly, either by enabling the "wrap" buffer mode as mentioned
previously, or by executing the \fIwrapLine\fR command which rewraps a block of lines.
The latter command, which is the second method for wrapping text, is in the "line" family and uses the
numeric prefix accordingly to identify a block of one or more lines to operate on.  When invoked,
it saves any indentation (white space) from the first line of the block, calls
\fIjoinLines\fR to convert the block to a single line by changing all embedded line breaks and surrounding white space to a
single space, then rewraps the line at the wrap column ($wrapCol) repeatedly,
inserting the indentation before each new line, until the remainder is too short to wrap any further.  The command calls the
\fIwrapWord\fR function with a numeric prefix equal to the end-of-indentation column to achieve this.
.Sp
Additionally, two options are available for line wrapping when these commands are called from a script.
\fIjoinLines\fR takes a \fInil\fR or string argument, the latter of which is a
list of characters to be considered the "end of a sentence".  When the command joins two lines, it will insert an extra space
if the first line ends with one of the specified characters and the second line is not blank or all white space.  The value
of the string argument is typically ".?!"; however, it can also be a null string to prevent this "extra space" behavior.
If the argument is \fInil\fR instead, the command will join lines with no space between them.
.Sp
The second available option is for the \fIwrapLine\fR command, which takes two arguments: a line "prefix",
and an end-of-sentence
string to pass to \fIjoinLines\fR.  The line prefix is a string that will be inserted after any indentation in each line
that is created during the wrapping process; for example, "# " or "// " to specify a comment in various
programming languages.  Existing prefix strings (with or without trailing white space)
are also recognized and removed from each line of the block
before \fIjoinLines\fR is called.  See the \fIbfFormatItem\fR macro in memacs-macros(1) for an example of this usage.
.SH "WINDOWS"
When working with multiple buffers (or files), it is often useful to split the screen into two or more windows and display
the buffers in separate windows.  This is accomplished with the \fIsplitWind\fR (\fIC-x 2\fR) command, which splits
the current window into two windows of equal size.
Initially, the current buffer is attached to both windows, which can be useful for
displaying different portions of it.  To display a different buffer in one of the windows, we use one of the same
commands we used before: \fInextBuf\fR, \fIprevBuf\fR, or \fIselectBuf\fR.
The entire process may then be repeated to create additional windows.
.Sp
The next obvious question is, "How do we adjust the sizes of each window?".  There are three commands for this:
\fIresizeWind\fR (\fIC-x w\fR), \fIgrowWind\fR (\fIC-x +\fR), and \fIshrinkWind\fR (\fIC-x -\fR).
These commands set, increase, or decrease the current window size by the number of rows specified with the numeric prefix.
.Sp
And likewise, there are commands for deleting windows as well: \fIdeleteWind\fR (\fIC-x 0\fR) deletes the
current window, \fIjoinWind\fR (\fIC-x j\fR) joins the current window with the window below it (by default),
and \fIonlyWind\fR (\fIC-x 1\fR) deletes all windows except the current one.  All the window commands can be
more finely controlled with a numeric prefix.  See the \fIshowBindings\fR command descriptions for details.
.Sp
To switch to another window, use \fInextWind\fR (\fIC-x n\fR) or \fIprevWind\fR (\fIC-x p\fR).  There are numeric
prefix options for these two commands as well.
.SH "BUFFER RENDERING"
As explained in the previous section, you can create multiple windows in MightEMacs, which is especially useful for working
with multiple buffers.  It can be tedious however, to set up the windows the way you want them.
MightEMacs provides some help with this by employing the following convention.  Mostly all buffer
and file commands may be given a numeric prefix in the range -2 to +3,
which controls the disposition or "rendering" of its buffer after the command completes.  The values of the numeric
prefix and their actions are:
.Sp
.in +.4i
< -1 
.in +1.9i
.sp -1v
Display buffer in a pop-up window with a basic mode line containing the buffer name and filename,
and delete the buffer afterward if it was just created.
.in
-1
.in +1.9i
.sp -1v
Same as < -1, except keep the existing mode line.
.in
0
.in +1.9i
.sp -1v
Leave the buffer as is (normally in the background).
.in
1
.in +1.9i
.sp -1v
Select the buffer; that is, attach and display it in the current window (the default action).
.in
2
.in +1.9i
.sp -1v
Display the buffer in another window, creating one if necessary.
.in
> 2
.in +1.9i
.sp -1v
Same as 2, except also switch to that window.
.PP
These numeric prefixes take a little while to learn and get used to, but they can definitely give you better control of your
editing sessions.  Here are some examples:
.Sp
.in +.4i
\fIC-u 3 C-x C-f\fR
.in +1.9i
.sp -1v
Find a file, display it in a new window, and switch to it.
.in
\fIC-_ C-x C-r\fR
.in +1.9i
.sp -1v
Display the on-disk version of a file in a pop-up window (whether or not it is currently being edited).
.in
\fIC-_ C-x C-f\fR
.in +1.9i
.sp -1v
Display a file in a pop-up window, using any existing buffer attached to that file (instead of the on-disk version)
if it exists.
.in
\fIC-u C-x C-b\fR
.in +1.9i
.sp -1v
Select a buffer (creating it if necessary) and display it in another window.
.in
\fIC-u C-u C-x C-f\fR
.in +1.9i
.sp -1v
Find a file, but don't select its buffer (to be edited later).
.SH "SCREENS"
In addition to windows, MightEMacs provides the option of creating multiple screens to manage buffers.
A screen is the entire display, containing all visible windows.  Multiple screens directly overlap each other (so only
one may be viewed at a time) and are numbered, beginning at 1.  If multiple screens exist, the number of the current
(frontmost) one is displayed in the mode line of the bottom-most window.
.Sp
Let's try this out.  Type the following command again to start the editor:
.Sp
.in +.4i
\&$ mm Notes.txt myscript.mm
.PP
At startup (usually), the first file is displayed in a single window on screen number 1.
Enter \fIC-x 2\fR to create another window,
then press \fIC-v\fR to move the point so the windows have different "looks" (on the same buffer).  Now press
\fIESC s\fR (\fInewScreen\fR) and observe that a second screen is created with just one window, and the
window's mode line now
contains "S2", identifying the screen.  Press \fIC-x ]\fR so that screen 2 is displaying a different buffer than screen 1.
And then use \fInextScreen\fR (\fIESC ]\fR) or \fIprevScreen\fR (\fIESC [\fR) to switch back to screen 1.
Notice that the first screen looks exactly as it did before.
This technique is very useful for keeping your places in various windows and buffers and quickly switching among them.
You can create as many screens as you like.
.Sp
The complete list of screen commands follows:
.Sp
.in +.4i
\fInewScreen\fR		\fIESC s\fR
.in +2.5i
.sp -1v
Create a new screen, assign the next available sequential number as its identifier, and switch to it.
.in
\fIdeleteScreen\fR	\fIESC C-d\fR
.in +2.5i
.sp -1v
Delete the screen specified by the numeric prefix (which must be in the background)
and renumber any other higher-numbered screens to "fill the hole".
.in
\fInextScreen\fR	\fIESC ]\fR
.in +2.5i
.sp -1v
Switch to the next (sequentially higher numbered) screen.
.in
\fIprevScreen\fR	\fIESC [\fR
.in +2.5i
.sp -1v
Switch to the previous (sequentially lower numbered) screen.
.in
\fIredrawScreen\fR	\fIESC l\fR
.in +2.5i
.sp -1v
Redraw the current screen and (usually) relocate the current line according to the numeric prefix.
.in
\fIshowScreens\fR	\fIC-h s\fR
.in +2.5i
.sp -1v
Display a list of all screens with their window numbers, buffer names, and filenames in a pop-up window.
An asterisk (*) is shown before the buffer name if the buffer has been modified.
.PP
See the individual command descriptions in the \fIshowBindings\fR display for more details.
.SH "KEYBOARD MACROS"
You may find during an editing session that you need to perform the same series of commands on multiple lines or
portions of text.  MightEMacs has the ability to save (or record) keystrokes in memory (a "keyboard macro")
and then play them back as many
times as you like, as if you had entered them by hand.
.Sp
The general method of recording and playing back a keyboard macro is as follows:
.Sp
.in +.4i
1.
.in +.3i
.sp -1v
Position the point at the beginning of the first text object (typically, the beginning of a line).
.in
2.
.in +.3i
.sp -1v
Start recording by entering \fIC-x (\fR (\fIbeginKeyMacro\fR).
.in
3.
.in +.3i
.sp -1v
Enter commands to change the first text object to the desired form and position the point at the
beginning of the next object when done.
.in
4.
.in +.3i
.sp -1v
Stop recording by entering \fIC-x )\fR (\fIendKeyMacro\fR).
.in
5.
.in +.3i
.sp -1v
Play back
the keyboard macro you just recorded for each of the remaining text objects by entering a numeric prefix followed by
\fIC-x e\fR (\fIxeqKeyMacro\fR).
.PP
For example, say you have the following lines of text and wish to convert them to an
initializer for an array variable for a C program you're working on:
.Sp
.in 1.1i
blue,32,The sky
.in 1.1i
green,7,Grass blades
.in 1.1i
red,1,Hot chile peppers
.in 1.1i
yellow,15,Ripe bananas
.PP
One way to do this is to position the point at the beginning of the first line (at the "b" of "blue"), then use the
following series of keys:
.Sp
.in +.4i
\fIC-x ( { C-u C-s , ESC " C-e " } ,\fR
\fIC-f C-x )\fR
.PP
This sequence does the following: begins a keyboard macro, inserts a left brace, searches for the second comma, inserts a double
quote character, moves to the end of line, inserts a double quote, a right brace,
and a comma, moves forward one character (to the beginning
of the next line), and ends recording.  Now it can be played back three times by isuing \fIC-u 3 C-x e\fR,
which produces the following result:
.Sp
.in 1.1i
{blue,32,"The sky"},
.in 1.1i
{green,7,"Grass blades"},
.in 1.1i
{red,1,"Hot chile peppers"},
.in 1.1i
{yellow,15,"Ripe bananas"},
.PP
This can definitely save you a lot of typing, especially when you have many similar text objects to edit.
You can also use the \fIseti\fR (\fIC-x i\fR) command to initialize the editor's internal "i" variable and the
\fIinserti\fR (\fIC-c i\fR) command in a keyboard macro to insert a series of numbers (ascending or descending),
optionally with associated text; for example,
to number (or renumber) a group of lines.  See the descriptions in the \fIshowBindings\fR display for the syntax.
You may want to experiment with this and see how it works.
.SH "WRITING SCRIPTS"
MightEMacs supports a powerful scripting language.  It allows you for example, to write your own "commands"
(or "macros" in Emacs terminology) which provides a means of extending the editor's features and capabilities to suit
your needs.  The language uses a C-like syntax for expressions and statements, which can be continued to subsequent lines.
Statements are used for looping, conditional execution, defining macros, and other purposes.
A macro that is defined in a script operates identically to a built-in command; that is, it accepts a numeric
prefix, can be bound to a key (and invoked interactively), and can be called from a script with arguments.
.Sp
Scripts are written in buffers or files and then executed with
the \fIxeqBuf\fR (\fIC-x x\fR) or \fIxeqFile\fR (\fIC-x /\fR) commands.  Script files may also be executed
from the command line when starting the editor or from another script (for example, from the "memacs.mm" site startup file).
.Sp
You can try this out for yourself in the editor.  Create a scratch buffer and enter the following lines:
.Sp
.in +0.4i
# Example script that defines a macro which accepts two arguments.
.sp +0v
macro example(2)
.in +0.4i
print "Base name of file '#{$1}' is '#{-1 => basename $1}'"
.sp +0v
$2
.in
endmacro
.PP
.Sp
Execute the buffer by entering \fIC-x x\fR and typing the name of the scratch buffer at the prompt.  Macro
\fIexample\fR is now defined.  (You can verify this via the \fIshowBindings\fR command.  You should see "example" near the
bottom of the list with no key binding or description.)
.Sp
Now let's execute the macro and capture it's return value in a global variable.  Type \fIESC C-x\fR (\fIeval\fR)
to execute a command line.  At the prompt, enter
"$result = example '/dir1/myfile.txt',77" and press \fIreturn\fR, which will run the macro.
You should see "Base name of file '/dir1/myfile.txt' is 'myfile'" in the message
line.  Now check the global variable.  Enter \fIC-h v G\fR and observe that variable $result has a value of 77.
.Sp
This was admittedly a contrived example of writing a script and a macro, but does illustrate the basics of how it's done.
For something more practical, consider the following.  Say you are testing a script and want to clear all hooks at the
beginning of it so that they will not be invoked when your script is run.
This script snippet accomplishes that by getting a list of all hook names into a buffer, positioning the point in the
buffer and looping through the lines, setting each hook to \fInil\fR by extracting its name from the line
and building a \fIsetHook\fR statement that is executed with the \fIeval\fR command, then deleting the temporary buffer:
.Sp
.in +0.4i
# Clear all hooks.
.sp +0v
bufName = 0 => showHooks
.sp +0v
1 => gotoLine 3,bufName
.sp +0v
until nil?(line = readBuf bufName)
.in +0.4i
null?(line) || eval "setHook '",strShift(line,' '),"',nil"
.in
endloop
.sp +0v
-1 => deleteBuf bufName
.PP
.Sp
As you can see, useful work can be done with just a few lines of code.
.Sp
Note in the first example that a macro was defined with a pair of keywords: \fImacro\fR and \fIendmacro\fR.  All "statement
keywords" must be the first word on a line (optionally preceded by white space), and must have either white space or a
left paren \fI(\fR between their names and their argument(s), if any.  The one exception is \fImacro\fR, which must be
followed by white space.
.Sp
Following is a list of all statement keywords and their usage:
.Sp
.in +0.4i
\fImacro name\fR[(\fIarg-count\fR)] [{\fIusage\fR: \fIstring\fR, \fIdesc\fR: \fIstring\fR}]
.sp 1v
.in +2.7i
.sp -1v
Begin a macro definition.  If the \fIarg-count\fR expression is specified, it must evaluate to a non-negative integer and
the macro must be called with that exact number of arguments or an error will occur.  If \fIarg-count\fR is not specified,
the macro may be called with any number of arguments (including none).  If the \fIusage\fR or \fIdesc\fR (description) value
is specified, the expression must evaluate to a non-null string.  Neither, one, or both may be specified, in any order,
enclosed in braces \fI{ }\fR.  The \fIusage\fR value is the argument syntax and the \fIdesc\fR value describes
the macro's purpose; for example, "macro fenceWord(1) {usage: 'char',desc: 'Wrap a pair of fences around [-]n word(s)'}".
.in
\fIendmacro\fR
.in +2.7i
.sp -1v
End the definition of the most recent macro being defined, which is determined by locating the most recent
unpaired \fImacro\fR keyword.  (Macro definitions
may be nested; that is, a macro can define a macro when it is executed.)
.in
\fIif and-or-expr\fR
.in +2.7i
.sp -1v
Begin an "if" statement.  The condition is true if the last expression of \fIand-or-expr\fR evaluates to true.
.in
\fIelsif and-or-expr\fR
.in +2.7i
.sp -1v
Specify an "else if" statement for the most recent unpaired \fIif\fR keyword.  The condition
is true if the \fIand-or-expr\fR expression evaluates to true and
the paired \fIif\fR and any prior \fIelsif\fR clauses that follow the \fIif\fR were false.
Zero or more \fIelsif\fR keywords may follow an \fIif\fR.
.in
\fIelse\fR
.in +2.7i
.sp -1v
Specify an "else" statement, which is true if the paired \fIif\fR and any \fIelsif\fR clauses that follow
the \fIif\fR were false.  Zero or one \fIelse\fR keywords may follow an \fIif\fR.
.in
\fIendif\fR
.in +2.7i
.sp -1v
End an "if" statement, which is determined by locating the most recent unpaired \fIif\fR keyword.
.in
\fIfor var in array-expr\fR
.in +2.7i
.sp -1v
Begin a "for" statement.  \fIarray-expr\fR is evaluated.  Then for each element in the array (which may be empty),
the value is assigned to variable \fIvar\fR and the block of statements following the keyword to its paired \fIendloop\fR is
executed.  If the array is empty, the block is not executed and \fIvar\fR is set to \fInil\fR.
.in
\fIwhile and-or-expr\fR
.in +2.7i
.sp -1v
Begin a "while" statement.  The block of statements following the keyword to its paired \fIendloop\fR is
executed while its condition is true (zero or more times).
.in
\fIuntil and-or-expr\fR
.in +2.7i
.sp -1v
Begin an "until" statement.  The block of statements following the keyword to its paired \fIendloop\fR is
executed until its condition is true (zero or more times).
.in
\fIloop\fR
.in +2.7i
.sp -1v
Begin a "loop" statement.  The block of statements following the keyword to its paired \fIendloop\fR is
executed an indefinite number of times (one or more).
The block must contain at least one \fIbreak\fR or \fIreturn\fR statement to prevent an endless do loop.
.in
\fIendloop\fR
.in +2.7i
.sp -1v
End a "while", "until", or "loop" statement, which is determined by locating the most recent unpaired
\fIwhile\fR, \fIuntil\fR, or \fIloop\fR keyword.
.in
\fIbreak\fR [\fIint-expr\fR]
.in +2.7i
.sp -1v
Break out of one (the default) or more enclosing loop blocks, determined by \fIint-expr\fR (if specified),
the last expression of which must evaluate to
an integer greater than zero.  Control is transferred to the end of the last block that is exited.
.in
\fIreturn\fR [\fIand-or-expr\fR]
.in +2.7i
.sp -1v
Exit a macro or executing buffer and return to the caller.  The return value is the last expression of \fIand-or-expr\fR
if specified; otherwise, \fInil\fR.
.in
\fIforce and-or-expr\fR
.in +2.7i
.sp -1v
Force the successful evaluation of \fIand-or-expr\fR; that is, ignore any error which may occur when it is evaluated.
.PP
It is also possible to create an alias of a command, function, or macro with the \fIalias\fR (\fIC-c C-a\fR) command.  An alias
of a command or macro has the same functionality as its counterpart, except that it cannot be bound to a key.
An alias of a function can only be used in a script or \fIeval\fR command line.
.PP
\fBData Types\fR
.in +.4i
.Sp
Several data types are supported in the scripting language:
.Bb
Variables and expressions are one of nil, Boolean, integer, string, or array types and with few exceptions,
are not automatically converted from one type to the
other when expressions are evaluated (like in the Perl language, for example).
However, you can use the \fItoInt\fR function to convert a numeric string literal to an integer,
and the \fItoString\fR function to convert any value to a string.  nil and Boolean types are coded using the
keywords \fInil\fR, \fItrue\fR, and \fIfalse\fR.  \fInil\fR represents a
"nothing" value and is different from a null string.  Additionally, the \fIdefn\fR keyword exists, which holds an integer value
equal to the default n argument.
.Le
.Bb
String literals are defined with single quotes (\fI'\fR) or double quotes (\fI"\fR).  Integers may be coded in any form which
is permitted by the strtol() function of the Standard C Library where the base is zero.
.Le
.Bb
A single-quoted string may contain \fI\\'\fR or
\fI\\\\\fR to specify an apostrophe or backslash character.  All other characters are taken literally.
.Le
.Bb
A double-quoted string may contain \fI\\"\fR, \fI\\\\\fR, \fI\\x\fR, \fI\\num\fR or \fI#{and-or-expr}\fR to specify a
double quote character, a backslash character, a special control character designated by the letter \fIx\fR,
an octal or hexadecimal value of a character, or an interpolated expression.  The \fI\\x\fR control characters and
their octal values are:
.in +0.4i
.sp
\fI\\r\fR	015	Carriage return
.sp +0v
\fI\\n\fR	012	Newline
.sp +0v
\fI\\t\fR	011	Tab
.sp +0v
\fI\\f\fR	014	Form feed
.sp +0v
\fI\\e\fR	033	Escape
.in -0.4i
.sp
To specify the octal or hexadecimal value of an ASCII character,
use \fI\\0nnn\fR (zero to three digits after the zero) or \fI\\0xnn\fR (one or two hexadecimal digits after the "x",
leading zero is optional); however, a null character (\fI\\0\fR) is not allowed.
.Sp
The result of an arbitrary expression may also be inserted into the string by using \fI#{and-or-expr}\fR (like in the Ruby
language), where
\fIand-or-expr\fR may itself contain a double-quoted string with an interpolated expression.  Nesting is allowed.
.in -0.4i
.Bb
\fI0\fR, \fIfalse\fR, and \fInil\fR are false;
all other expressions and variable values (including null strings \fI''\fR and \fI""\fR) are true.
.Le
.PP
\fBArrays\fR
.in +.4i
.Sp
There are several operators and functions for creating and manipulating arrays:
.Bb
Arrays are defined by enclosing zero or more comma-separated values within brackets \fI[ ]\fR.
Array elements are specified using an integer index in brackets immediately
following the array expression with no intervening white space.  It is also
possible to create an array "slice" by using two indices which specify an offset and length.  For example:
.Sp
.in +0.4i
x = ['blue',true,[$bufName,0],env 'HOME']
.Sp
y = x[0]
.in +3.4i
.sp -1v
# y is the string "blue".
.in -3.4i
z = x[2]
.in +3.4i
.sp -1v
# z is the array [$bufName,0].
.in -3.4i
new = x[0,2]
.in +3.4i
.sp -1v
# new is the array ["blue",true].
.PP
.in +.4i
.Bb
Arrays may also be created by using the following functions:
.Sp
.in +.4i
\fIarray\fR [\fIsize\fR[,\fIinitializer\fR]]
.in +3.4i
.sp -1v
Create an array.  If \fIsize\fR is omitted, an empty array will be created; otherwise, an array of \fIsize\fR elements will
be created with each element set to \fInil\fR.
If \fIinitializer\fR is given, each of the \fIsize\fR elements will be set to a copy of the \fIinitializer\fR value
instead (which may also be an array).
.in
\fIclone ary\fR
.in +3.4i
.sp -1v
Create a copy of \fIary\fR and
return it.  The new array is an exact copy of the original, including nested arrays if any.
.in
\fIsplit delim\fR,\fIstring\fR[,\fIlimit\fR]
.in +3.4i
.sp -1v
Convert a delimited string into an array.  The delimiter may be a single character or ' ' for white space.  In the latter case,
leading white space in \fIstring\fR is ignored.  If \fIlimit\fR < 0, each delimiter found in \fIstring\fR is significant and
delineates two substrings, either or both of which may be null.  If \fIlimit\fR == 0 (default), trailing null substrings are
suppressed.  If \fIlimit\fR > 0, it is the maximum number of array elements to create.  In this case, the last element of the
array will contain embedded delimiter(s) if the number of delimiters in the string is >= \fIlimit\fR.
.PP
.in +.4i
.Bb
Arrays may be "auto extended" by assigning a value to an element beyond the end of the array.  The intervening elements
if any, are set to \fInil\fR.  For example, the sequence "x = [1,2]; x[3] = false" would set "x" to "[1,2,nil,false]".
.Le
.Bb
Arrays may be compared with the \fI==\fR or \fI!=\fR operators,
and may be specified as the second argument to the \fIinclude?\fR
function, such as "include? [1,[2,3],4],[2,3]" (which would return \fItrue\fR).
.Le
.Bb
Arrays may also be concatenated with other values via the \fI&\fR or \fI&=\fR operators.  If the first argument of the
expression is string, all following arguments will be converted to string, including arrays, and the result will be string.
However, arrays will be processed recursively as if each element was specified separately.  If the first argument of the
concatenation expression is an array, the result will be a new array containing a clone of the first array plus all following
arguments appended to it as separate elements.  Any array argument will be "exploded" into separate arguments first.
Following are some examples:
.Sp
.in +0.4i
\'Blue' & 'Sky' & nil & 5
.in +3.4i
.sp -1v
# -> "BlueSky5".
.in -3.4i
\'Red' & [01,['Green',false]]
.in +3.4i
.sp -1v
# -> "Red1Greenfalse".
.in -3.4i
[0] & true & [nil,[3,4]]
.in +3.4i
.sp -1v
# -> [0,true,nil,[3,4]].
.in -3.4i
x = []
.sp +0v
x & 'Red'
.in +3.4i
.sp -1v
# x is []; result is ["Red"].
.in -3.4i
x = []
.sp +0v
x &= 'Red'
.in +3.4i
.sp -1v
# x is ["Red"]; result is ["Red"].
.PP
\fBGeneral\fR
.in +.4i
.Sp
When writing scripts, note the following:
.Bb
A script consists of zero or more lines.  Blank lines and lines that begin with \fI#\fR as the first non-whitespace character
(a comment) are ignored.  Comments may also occur at the end of a line.  All remaining lines or portions of lines
are interpreted as statements.
.Le
.Bb
Any line except a line containing a comment may be continued to the next line by placing a backslash (\fI\\\fR) at the end of
it.  The line and the following line will be interpreted as if they were joined and the backslash was removed.  Backslashes may
be appended to multiple consecutive lines as well, to join more than two lines.  The entire block of lines will
be interpreted as a single statement.
.Le
.Bb
A statement consists of an optional statement keyword followed by an optional \fIand-or-expr\fR, which is a series of one or
more expressions separated by \fIand\fR or \fIor\fR.
.Le
.Bb
There are two types of variables: global and local.  Global variables begin with a dollar sign (\fI$\fR), have global
scope, and are permanent.  Local variables do not have a leading dollar sign,
are accessible only within the script or macro in which they are
created (assigned to), and are deleted when the script or macro exits.  Predefined global variables whose names begin with
a capital letter (for example, $LineLen) are read-only and thus, cannot be assigned to.
.Le
.Bb
Multiple variables may be assigned to elements of an array by separating the variable names with a comma on the left side of
the assignment operator; for example:
.sp +1v
.in +0.4i
arr = []
.sp 0v
a,b,arr[0] = [1,false,'xyz']
.in
.sp +1v
If there are more elements than variables, the extra elements will be ignored.  If there are more variables than elements,
the extra variables will be set to \fInil\fR.
.PP
.in +.4i
.Bb
A command, alias, function, or macro may be called with zero or more argument(s) separated by commas, and may also be
called with an n argument.
An n argument is passed via the binary operator \fI=>\fR using the syntax
\fIint-expr => name\fR, where \fIint-expr\fR is the n argument and \fIname\fR
is the command, alias, function, or macro name.  The \fI=>\fR operator has high precedence in an expression.  (See
file "Syntax.txt" for a description of all statements, expressions, operators, and their precedences.)
.Le
.Bb
A buffer containing a script may be executed just like a macro
by using the \fIxeqBuf\fR command.  The command essentially acts as a "macro proxy" and is called
with an optional n argument and a comma-separated list of arguments, the first of which must evaluate
to the name of the buffer to execute.  The n argument (if any) and all arguments after the first are passed to the script.
.Le
.Bb
A command, alias, function, or macro that is called with argument(s) may be coded
with or without parentheses around the argument list;
that is, in form "\fIname\fR(\fIarg1\fR,\fIarg2\fR,...)" or "\fIname arg1\fR,\fIarg2\fR,...".  However, be
aware that the latter form is more prone to ambiguity and may induce a syntax error.  If parentheses are used, there must not
be any white space between the function name and the left \fI(\fR parenthesis; otherwise, it will be
interpreted as an unparenthesized function call (the second form) with the first argument in parentheses.
The first form is also used to specify zero arguments, as in "\fIname\fR()".  The parentheses may be required in
this case to prevent tokens that follow \fIname\fR from being interpreted as its arguments.
.Le
.Bb
The n argument is accessed from a macro or executing buffer via the $0 variable.  Other arguments
are accessed via the $1, $2, ... variables or the $ArgVector array.  All $\fIn\fR variables may be assigned to,
although $0 must be an integer value.  The $ArgVector variable may not be assigned to; however, its (array) contents
may be modified just like any other array.  Note that the $1, $2, ... variables are just "shortcuts" for
$ArgVector[0], $ArgVector[1], ... and will change if the $ArgVector array is changed.
.Le
.Bb
All scripts and macros are invoked as functions and return a value, which is the result of the last expression statement
evaluated, the value of a \fIreturn\fR statement, or \fInil\fR by default.
.Le
.Bb
Return messages (which are different from return \fBvalues\fR) are generated by certain commands and by using the
\fInotice\fR function in a script or macro.  While a script is
executing, the most recent return message is available in the $ReturnMsg variable.  A message from a command (like
\fIsetMark\fR or \fIcopyLine\fR) has low priority and will not replace an existing message.  The \fInotice\fR function however,
has high priority and will always replace an existing message.  The disposition of a message is also dependent on the current
state of the "msg" global mode.  If message mode is off, command messages are not saved, but \fInotice\fR messages
still are.  When control is eventually returned to the user, the final saved message (if any) is displayed
on the message line.  Note that if a script writes a message directly to the message
line (via the \fIprint\fR function), it will be overwritten by any return message and thus may not be seen,
depending on script execution time.  The \fIpause\fR function can be used in this case as a workaround.
.Le
.Bb
The \fIbinding\fR function and the \fIbindKey\fR and \fIunbindKey\fR commands take a key binding as their first argument.  Key
bindings are specified in a coded string form as one or two "key literals" separated by a space.  A key literal is defined as:
.Sp
.in +.4i
Zero or more of the following with no intervening space:
.Sp
.in +.4i
M-
.in +.8i
.sp -1v
Meta prefix key.
.in
C-
.in +.8i
.sp -1v
Control key.
.in
S-
.in +.8i
.sp -1v
Shift key.
.in
FN
.in +.8i
.sp -1v
Function key.
.in
.in -.4i
.sp
which is followed by a printable character or character literal with no intervening space.
.sp
.in -.4i
Character literals are any of the following (in upper case only):
.sp
.in +.4i
DEL
.in +.8i
.sp -1v
\fIdelete\fR key.
.in
ESC
.in +.8i
.sp -1v
\fIescape\fR key.
.in
RTN
.in +.8i
.sp -1v
\fIreturn\fR key.
.in
SPC
.in +.8i
.sp -1v
Spacebar.
.in
TAB
.in +.8i
.sp -1v
\fItab\fR key.
.in
.in -.4i
.sp
Additionally, "^\fIx\fR" may be substituted for "C-\fIx\fR" to specify a control character, although the latter
syntax is preferred.  Some examples are:
.Sp
.in +.4i
\fBKey(s)\fR
.in +4.0i
.sp -1v
\fBCoded string form\fR
.in
.sp
\fIcontrol\fR + \fIf\fR
.in +4.0i
.sp -1v
"C-f" (or "^F")
.in
\fIesc\fR
.in +4.0i
.sp -1v
"ESC" (or "C-[")
.in
\fIreturn\fR
.in +4.0i
.sp -1v
"RTN" (or "C-m" or "C-M")
.in
Right arrow
.in +4.0i
.sp -1v
"FNF"
.in
Shift left arrow
.in +4.0i
.sp -1v
"S-FNB"
.in
\fIcontrol\fR + \fIx\fR followed by \fIk\fR
.in +4.0i
.sp -1v
"C-x k" (or "^x k")
.in
\fIesc\fR followed by \fIesc\fR
.in +4.0i
.sp -1v
"M-ESC" (or "M-C-[" or "ESC ESC")
.in
The carat key \fI^\fR
.in +4.0i
.sp -1v
"^"
.in
\fIcontrol\fR + \fIh\fR followed by carat \fI^\fR
.in +4.0i
.sp -1v
"C-h ^" (or "^H ^")
.in
\fIcontrol\fR + carat
.in +4.0i
.sp -1v
"C-^" (or "^^")
.in
\fIcontrol\fR + \fIspacebar\fR (null character)
.in +4.0i
.sp -1v
"C-SPC" (or "C-@" or "^@")
.in
\fIdelete\fR key
.in +4.0i
.sp -1v
"DEL" (or "C-?" or "^?")
.in
\fIesc\fR followed by \fIcontrol\fR + space
.in +4.0i
.sp -1v
"M-C-SPC" (or "ESC C-SPC" or "^[ ^SPC")
.in
\fIesc\fR followed by space
.in +4.0i
.sp -1v
"M-SPC" (or "ESC SPC")
.in
The letter \fIQ\fR (upper case)
.in +4.0i
.sp -1v
"Q" (or "S-q" or "S-Q")
.in
.in -.4i
.sp
Coded bindings are not case-sensitive, with the exception of the character literals (like "ESC") or
a single-letter binding (like "f"), which are.  Consequently,
"C-h F" is the same key sequence as "c-H f", but "x" is different than "X".  Also, raw 7-bit characters greater than
zero may be specified for any control character and the delete key,
so the pairs "C-a" and "\\1", "C-m" and "\\r", and "C-DEL" and "\\x7f" are the same.
.Le
.PP
See the \fIshowBindings\fR, \fIshowFunctions\fR, and \fIshowVariables\fR listings for descriptions of all the
commands, functions, and variables which are available for use in a script.
.Sp
Lastly, note that all commands (and macros) return \fInil\fR by default.  The following commands however, have different
return values:
.Sp
.in 1.1i
\fBCommand\fR
.in +1.8i
.sp -1v
\fBReturn value\fR
.Sp
.in 1.1i
\fIalterBufMode\fR
.sp 0v
\fIalterDefMode\fR
.sp 0v
\fIalterGlobalMode\fR
.sp 0v
\fIalterShowMode\fR
.in +1.8i
.sp -1v
Former state (-1 or 1) of last mode altered.  (The value can be used as the n argument of a subsequent command to
restore the former state of that mode.)
.in 1.1i
\fIappendFile\fR
.in +1.8i
.sp -1v
Filename.
.in 1.1i
\fIbackChar\fR
.sp 0v
\fIbackLine\fR
.sp 0v
\fIbackWord\fR
.in +1.8i
.sp -1v
\fIfalse\fR if hit a buffer boundary; otherwise, \fItrue\fR.
.in 1.1i
\fIchDir\fR
.in +1.8i
.sp -1v
Absolute pathname of new directory.
.in 1.1i
\fIclearBuf\fR
.in +1.8i
.sp -1v
\fIfalse\fR if buffer is not cleared; otherwise, \fItrue\fR.
.in 1.1i
\fIdeleteBuf\fR
.in +1.8i
.sp -1v
Name of last buffer deleted (last command argument).
.in 1.1i
\fIeval\fR
.in +1.8i
.sp -1v
Result of evaluation.
.in 1.1i
\fIfindFile\fR
.in +1.8i
.sp -1v
Two-element array containing name of buffer, and \fItrue\fR or \fIfalse\fR indicating whether the buffer was created.
.in 1.1i
\fIendWord\fR
.sp 0v
\fIforwChar\fR
.sp 0v
\fIforwLine\fR
.sp 0v
\fIforwWord\fR
.in +1.8i
.sp -1v
\fIfalse\fR if hit a buffer boundary; otherwise, \fItrue\fR.
.in 1.1i
\fIhideBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIhuntBack\fR
.sp 0v
\fIhuntForw\fR
.in +1.8i
.sp -1v
String found, or \fIfalse\fR if not found.
.in 1.1i
\fIinsertBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIinsertFile\fR
.in +1.8i
.sp -1v
Filename.
.in 1.1i
\fIinsertPipe\fR
.in +1.8i
.sp -1v
\fIfalse\fR if failure; otherwise, \fItrue\fR.
.in 1.1i
\fIlastBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fInewScreen\fR
.in +1.8i
.sp -1v
New screen number.
.in 1.1i
\fInextBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fInextScreen\fR
.in +1.8i
.sp -1v
New screen number.
.in 1.1i
\fIpipeBuf\fR
.in +1.8i
.sp -1v
\fIfalse\fR if failure; otherwise, \fItrue\fR.
.in 1.1i
\fIprevBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIprevScreen\fR
.in +1.8i
.sp -1v
New screen number.
.in 1.1i
\fIqueryReplace\fR
.in +1.8i
.sp -1v
\fIfalse\fR if search stopped prematurely; otherwise, \fItrue\fR.
.in 1.1i
\fIreadFile\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIreadPipe\fR
.in +1.8i
.sp -1v
Name of buffer, or \fIfalse\fR if failure.
.in 1.1i
\fIrun\fR
.in +1.8i
.sp -1v
Execution result.
.in 1.1i
\fIscratchBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIsearchBack\fR
.sp 0v
\fIsearchForw\fR
.in +1.8i
.sp -1v
String found, or \fIfalse\fR if not found.
.in 1.1i
\fIselectBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIsetBufFile\fR
.in +1.8i
.sp -1v
New filename.
.in 1.1i
\fIsetBufName\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIshell\fR
.sp 0v
\fIshellCmd\fR
.in +1.8i
.sp -1v
\fIfalse\fR if failure; otherwise, \fItrue\fR.
.in 1.1i
\fItruncBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIunbindKey\fR
.in +1.8i
.sp -1v
Boolean result if n > 0; otherwise, \fInil\fR.
.in 1.1i
\fIunchangeBuf\fR
.sp 0v
\fIunhideBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIviewFile\fR
.in +1.8i
.sp -1v
Two-element array containing name of buffer, and \fItrue\fR or \fIfalse\fR indicating whether the buffer was created.
.in 1.1i
\fIwriteFile\fR
.in +1.8i
.sp -1v
Filename.
.in 1.1i
\fIxeqBuf\fR
.sp 0v
\fIxeqFile\fR
.in +1.8i
.sp -1v
Execution result.
.SH "MIGHTEMACS SHELL SCRIPTS"
A MightEMacs script may be invoked in a number of different ways, including from the shell command line using
a "@filename" argument (see memacs(1) for details).  You can take this concept one step further by executing
a script file directly from the shell; that
is, instead of typing "memacs ... @myscript ...", you can just type "myscript ..." at the shell command prompt.
This is accomplished by specifying the pathname to the "memacs" binary with the \fB-S\fR switch
in the first line of the script as a shell comment; for example:
.Sp
.in +0.4i
#!/usr/local/bin/memacs -S
.sp +1v
# Example script that can be executed from the shell.
.sp +0v
readFile $1
.sp +0v
markBuf
.sp +0v
0 => trimLine
.sp +0v
beginBuf
.PP
.Sp
This script will open the file specified as an argument, trim white space from all lines, then move the point back to the
beginning of the buffer.  When the script ends, control is passed back to the user.  Note that any arguments specified on the
command line are available (exclusively) to the script as $1, $2, ..., etc. and when the script starts, the current buffer
is "untitled".
.SH "USER INPUT"
It is possible to get user input from a script by using the \fIprompt\fR function, which displays a prompt on the message
line, reads a response, and returns the result.  When using the function, note the following:
.in +.4i
.Bb
It accepts one to four arguments in the following order:
.Sp
.in +.4i
1.
.in +.3i
.sp -1v
A prompt string.
.in
2.
.in +.3i
.sp -1v
A default value.
.in
3.
.in +.3i
.sp -1v
A prompt type, specified as a single-character string.
.in
4.
.in +.3i
.sp -1v
An input delimiter, specified in the same format as a key binding.
.in
.in -.4i
.sp
The first argument is required; all other arguments are optional.  However, no arguments may be skipped and the fourth
argument is allowed only for 'c' and 's' prompt types.
.Le
.PP
.in +.4i
.Bb
If a default value is specified (including a null string), it is displayed after the prompt string between square
brackets \fI[ ]\fR and is returned as the function result if the user enters just the delimiter key.  The default value may
also be specified as \fInil\fR for none (the default).
If there is no default value and the user enters just the delimiter key, the function returns \fInil\fR.  If on the other
hand, the user presses \fIC-k\fR, the function returns a null string instead.
.Le
.Bb
The type argument provides input options and is specified as an optional \fI^\fR character plus one option letter, as follows:
.Sp
.in +.4i
\fI^\fR
.in +1.1i
.sp -1v
Disable auto-completion; that is, wait for the delimiter to be entered before returning.  Must be the first character of
the type argument.
.in
\fIb\fR
.in +1.1i
.sp -1v
Enable buffer name completion during input.
.in
\fIc\fR
.in +1.1i
.sp -1v
Read a single character (one keystroke) and return it in key binding format.
.in
\fIf\fR
.in +1.1i
.sp -1v
Enable filename completion during input.
.in
\fIs\fR
.in +1.1i
.sp -1v
Read a string without completion (the default).
.in
\fIV\fR
.in +1.1i
.sp -1v
Enable variable name completion during input and include all system and global variables.
.in
\fIv\fR
.in +1.1i
.sp -1v
Enable variable name completion during input, but exclude all read-only system variables and global variables that
begin with a capital letter.
.Le
.in -.7i
.Bb
The input delimiter may be specified when the prompt type is 'c' or 's'.  It can be \fInil\fR or "RTN", either of which
specifies the default delimiter (the \fIreturn\fR key), or a different key (for example, the \fIesc\fR key,
coded as "ESC") so that \fIreturn\fR can be entered as part of the input string.
.Le
.SH "HOOKS"
Certain operations during an editing session may be controlled or customized by assigning the name of a
macro to a "hook".  Operations include switching buffers, reading or writing a file, and executing keys.
When a hook is triggered, the macro associated with the hook is called with arguments, if applicable (see below).
If an error occurs during execution or the macro returns false (that is, the value of the
\fIfalse\fR keyword), an error message is displayed and the hook is disabled.
.Sp
Note that you cannot assign a command or function to a hook because it makes no sense to do so.  The one exception is the "wrap"
hook which is set to the \fIwrapper\fR macro (discussed previously) by default.  The \fIwrapWord\fR function, which is called by
the \fIwrapper\fR macro, is designed just for this purpose.
.Sp
A hook is set or cleared with the \fIsetHook\fR (\fIC-x h\fR) command, usually in a script.  For example,
this line from the "memacs.mm" startup file:
.Sp
.in +0.4i
setHook 'help',getHelp
.in
.Sp
sets the "help" hook to the \fIgetHelp\fR macro.  To clear a hook, set it to \fInil\fR.
To see all hooks and their settings, enter \fIC-h h\fR (\fIshowHooks\fR).
.Sp
The complete list of hooks follows:
.Sp
.in 1.1i
\fBHook name\fR
.in +1.6i
.sp -1v
\fBMacro arguments\fR
.in +2.0i
.sp -1v
\fBDescription\fR
.Sp
.in 1.1i
chDir
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Change-directory hook -- called at program startup and after the \fIchDir\fR command is executed.
.in 1.1i
exitBuf
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Exit-buffer hook -- called just before leaving a buffer.  $bufName is the name of the buffer being exited.  Its return
value is passed to the enter-buffer hook.
.in 1.1i
enterBuf
.in +1.6i
.sp -1v
exitBuf return
 value
.in +2.0i
.sp -2v
Enter-buffer hook -- called after switching to another buffer.  $bufName is the name of the buffer being entered.
.in 1.1i
help
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Help hook -- called when the \fIhelp\fR command is executed.
.in 1.1i
mode
.in +1.6i
.sp -1v
$globalModes,
 $showModes,
 $defBufModes,
 $bufModes
.in +2.0i
.sp -4v
Mode-change hook -- called whenever any mode is changed.  Arguments are the prior variable values.  (Each argument value
can be compared to the current value of the same variable to find the one that was changed.)
.in 1.1i
preKey
.in +1.6i
.sp -1v
Entered key
.in +2.0i
.sp -1v
Pre-key hook -- called after a key sequence is entered, but before it is executed.  The hook macro may set a new key to be
executed by assigning one to the $lastKeySeq variable.  It may also prevent the current key from being executed by
returning a true value.
.in 1.1i
postKey
.in +1.6i
.sp -1v
Entered key
.in +2.0i
.sp -1v
Post-key hook -- called immediately after a key sequence is executed (or skipped if the pre-key hook returned true).
The argument is the same one given to the pre-key hook.  $lastKeySeq will (usually) contain the key that was
actually executed.
.in 1.1i
read
.in +1.6i
.sp -1v
Buffer name,
 filename
.in +2.0i
.sp -2v
Read-file hook -- called after a file is read into a buffer.  The second (filename)
argument will be \fInil\fR if standard input was read.
.in 1.1i
write
.in +1.6i
.sp -1v
Buffer name,
 filename
.in +2.0i
.sp -2v
Write-file hook -- called just before a file is written to disk.
.Sp
.in 1.1i
wrap
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Wrap-word hook -- called when the "wrap" buffer mode is enabled, the "rdonly" buffer mode is disabled,
a space or return was entered, and the point is at or past the wrap column ($wrapCol).
.SH "TERMINAL DIMENSIONS"
Part of MightEMacs's startup processing is to map its screen to the size of the terminal window.  It can also do this
during an editing session if the size of the terminal window changes; for example, when changing the orientation of a
smart phone from portrait to landscape or vice-versa.  To update the screen dimensions, use
the \fIresetTerm\fR (\fIESC ESC\fR) command.
.SH "SEE ALSO"
memacs(1), memacs-macros(1)
