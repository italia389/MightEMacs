~bScripting Introduction~0

In addition to editing files, one of MightEMacs primary features is
extensibility through the use of a powerful scripting language.  For example,
you can write your own "commands" (or "macros" in MightEMacs
terminology) which provides a means of extending the editor's features and
capabilities to suit your needs.  The language uses a C-like syntax for
expressions and statements, which can be continued to subsequent lines.
Statements are used for looping, conditional execution, defining macros, and
other purposes.  A macro that is defined in a script operates identically to a
built-in command; that is, it accepts a numeric prefix, can be bound to a key
(and invoked interactively), can be called from a script with arguments, and
returns a value.

Scripts are written in buffers or files and then executed with the ~uxeqBuf~U
(~#uC-x x~U) or ~uxeqFile~U (~#uC-x /~U) command.  Script files may also be executed from the
command line when starting the editor or from another script (for example, from
the "memacs.mm" site startup file or the "~/.memacs" user startup file).

You can try this out for yourself in the editor.  Create a scratch buffer and
enter the following lines:

    # Example script that defines a macro which accepts two arguments.
    macro example(2)
        print "Base name of file '#{$1}' is '#{-1 => basename $1}'"
        $2
    endmacro

Execute the buffer by entering ~#uC-x x~U and typing the name of the scratch buffer
at the prompt.  Macro ~uexample~U is now defined.  (You can verify this via the
~ushowMacros~U (~#uC-h @~U) command.  You should see "example" in the list with no key
binding or description.)

Now let's execute the macro and capture it's return value in a global variable.
Type ~#uESC C-x~U (~ueval~U) to execute a command line.  At the prompt, enter:

    $result = example '/dir1/myfile.txt',77

and press ~ureturn~U, which will run the macro.  You should see:

    Base name of file '/dir1/myfile.txt' is 'myfile'

on the message line.  Now check the global variable.  Enter ~#uC-h v G~U and observe
that variable $result has a value of 77.

This was admittedly a contrived example of writing a script and a macro, but
does illustrate the basics of how it's done.  For something more practical,
consider the following.  Say you are testing a script and want to clear all
hooks at the beginning of it so that they will not be invoked when your script
is run.  This script snippet accomplishes that by getting a list of all hook
names into a buffer, positioning the point in the buffer and looping through the
lines, setting each hook to ~unil~U by extracting its name from the line and
building a ~usetHook~U statement that is executed with the ~ueval~U command.  Lastly, it
deletes the temporary buffer:

    # Clear all hooks.
    bufName = (0 => showHooks)[0]
    1 => gotoLine 3,bufName
    until nil?(line = bgets bufName)
        !null?(line) && substr(line,0,1) != ' ' &&\
         eval "setHook '",strShift(line,' '),"',nil"
    endloop
    deleteBuf bufName

As you can see, useful work can be done with just a few lines of code.  Note
that this script snippet uses the ~ushowHooks~U command to get all the hooks names.
This was the only way to obtain them prior to version 9.0 of the editor.  Now
the ~ugetInfo~U function is available.  It provides various types of system and
session information, including hook names.  Here is the same script snippet
rewritten to use ~ugetInfo~U:

    # Clear all hooks.  getInfo returns hooks as an array in
    # form: [[hook-name,macro-name],...].
    for hookInfo in getInfo('Hooks')
        eval "setHook '",hookInfo[0],"',nil"
    endloop

This version is definitely more succinct and straightforward.
