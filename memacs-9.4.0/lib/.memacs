# .memacs	Ver. 9.4.0
#	MightEMacs user startup file.

# Pop or open file whose pathname is in current buffer.
macro openBufPath(0) {desc: 'Extract a pathname from current buffer and display the file in a pop-up window or open it.  User\
 is prompted for one or two of the following options: "FindFile" -> open file with ~bfindFile~B command; "PopFile" -> display\
 the file in a pop-up window; and "UseRegion" -> use region contents as pathname.  Either "FindFile" or "PopFile" must be\
 specified.  If "UseRegion" not specified, pathname is extracted from buffer at point and is assumed to be bounded by white\
 space and/or line breaks.'}

	# Get options.
	if empty?(options = prompt('Options (~u~bF~ZindFile, ~u~bP~ZopFile, Use~u~bR~Zegion)','TermAttr'))
		return nil
	elsif (optionsLC = lowerCaseStr(options)) !~ '^[fpr]+$'
		return -1 => message nil,'Invalid options "',options,'"'
	endif

	findPop = nil
	useRegion = false
	loop
		option = strShift(optionsLC,nil)
		if option == 'f' || option == 'p'
			if findPop != nil
				return -1 => message nil,'"FindFile" and "PopFile" cannot both be specified'
			else
				findPop = option
			endif
		else	# option == 'r'
			useRegion = true
		endif
		if empty? optionsLC
			break
		endif
	endloop
	if nil? findPop
		return -1 => message nil,'Either "FindFile" or "PopFile" must be specified'
	endif

	# Get pathname.
	if useRegion
		path = $RegionText
	else
		# Do sanity checks.
		goBack = true
		if $lineChar == ?\s || $lineChar == ?\t
			endWhite
			if $lineChar == ?\n
				return 0 => message(nil,'Pathname not found')
			endif
			goBack = false
		endif

		# Find beginning and end of pathname.
		oldMsgState = -1 => chgMode(nil,'RtnMsg')
		wordChars = $wordChars
		$wordChars = '!-~'
		1 => setMark ??
		goBack and backWord
		setMark
		endWord
		path = $RegionText
		-1 => gotoMark ??
		$wordChars = wordChars
		oldMsgState => chgMode nil,'RtnMsg'
	endif

	# Open or pop file.
	if !empty?(path = 1 => prompt(findPop == 'f' ? 'Find file' : 'Pop file',path,'Type: File'))
		if findPop == 'f'
			findFile path
		else
			1 => popFile path,'AltModeLine,Delete'
		endif
	endif
endmacro

# Pop a list of all buffers.
macro popBufAll(0) {desc: 'Display all buffers in a pop-up window.'}
	oldMsgState = -1 => chgMode(nil,'RtnMsg')
	bufname = (0 => showBuffers)[0]
	1 => popBuf bufname,'Delete'
	oldMsgState => chgMode nil,'RtnMsg'
endmacro

# Put current keyboard macro into a scratch buffer so it can be edited.
macro editKeyMacro(0) {desc: 'Edit current keyboard macro.'}
	scratchBuf
	insert "# Edit next line, then enter \"C-x x\" to execute this buffer and set the new macro contents.\n\
$keyMacro = '",$keyMacro,"'"
	beginLine
endmacro

bindKey 'ESC E',editKeyMacro
bindKey 'C-x O',openBufPath
bindKey 'C-h B',popBufAll
