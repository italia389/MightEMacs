.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Bb \" Begin bullet item
.if t .sp .5v
.if n .sp
\fB*\fR
.in +.32i
.sp -1
..
.de Lb \" Begin list item
.if t .sp .5v
.if n .sp
\\$1
.in +.32i
.sp -1
..
.de Le \" End (bullet or) list item
.in
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.TH MEMACS-GUIDE 1 "2015-10-24" "memacs 8.1.0" "MightEMacs Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
memacs\-guide \- MightEMacs Tutorial and User's Guide
.SH "ABSTRACT"
This document describes the basics of editing files with MightEMacs and writing
scripts and macros to extend its features.  It also
contains instructive examples and information about its operation that is not available in the editor's help system.
.SH "EDITING A FILE"
The main purpose of any text editor is to edit files, so let's begin with a simple editing session.  You may
invoke MightEMacs with either the \fBmm\fR or \fBmemacs\fR command.  It can perform startup actions
as well (see memacs(1) for details).  Type the following at a shell prompt:
.Sp
.in +.4i
\&$ mm myscript.mm
.PP
A full-screen window opens displaying the first portion of the file.  If the file does not exist, the window will be
blank (as in this example).  The "mode line" in reverse video near the bottom of the screen contains basic information
about the editing session:
.Sp
.in +.4i
=== MightEMacs 8.1.0 (Exact) [Memacs] == myscript == File: myscript.mm ==========
.PP
This says that we are running version 8.1.0 of the editor
with global mode \fIExact\fR and buffer mode \fIMemacs\fR enabled
(the latter of which was activated by the \fIsetLangMode\fR macro in site startup file "memacs.mm").  The buffer name
is "myscript" (derived from the filename) and the file pathname is "myscript.mm".
.Sp
Type a few lines of text and notice that an asterisk appears at the beginning of the mode line in the second column.  This is an
indicator that the buffer has been modified.  To move the cursor around, use the arrow keys or press \fI^F\fR (\fIforwChar\fR),
\fI^B\fR (\fIbackChar\fR), \fI^P\fR (\fIprevline\fR), or
\fI^N\fR (\fInextline\fR).  You can also jump to the end of a line (\fI^E\fR), the beginning (\fI^A\fR), traverse a
line quickly in either direction (press \fI^T\fR repeatedly), move forward
a page (\fI^V\fR), back a page (\fI^Z\fR), jump to the beginning of the buffer (\fIESC\fR \fI<\fR),
or to the end (\fIESC\fR \fI>\fR).
.Sp
Let's save our changes.  Press \fI^X\fR \fI^S\fR (\fIsaveFile\fR).
The asterisk changes back to "=" and you get some feedback in the "message line" at the bottom of the screen.
.Sp
Now let's make a few more changes, save the file again, and exit the editor.  Type a few characters so the buffer is
changed.  We can save the changes again by pressing \fI^X\fR \fI^S\fR and then exit by pressing
\fI^X\fR \fI^C\fR (\fIexit\fR).  However,
let's do this in one step instead.  Press \fIESC\fR \fIZ\fR (\fIquickExit\fR).  The file is saved and we're back to the shell.
.SH "EDITING MULTIPLE FILES"
Multiple files can be edited in a couple of ways.  One way is to simply specify more than one file when invoking the editor.
For example, type the following:
.Sp
.in +.4i
\&$ mm Notes.txt myscript.mm
.PP
As before, a full-screen window opens displaying the first portion of the first file.  A buffer for the
second file was created also,
but it is currently in the background.  To bring it to the foreground, use the \fInextBuf\fR (\fI^X\fR \fI]\fR) or
\fIprevBuf\fR (\fI^X\fR \fI[\fR) command.  Notice that the file is read at the same time.  (MightEMacs delays reading a
file if possible, until its buffer is selected.)  The \fIshowBuffers\fR command (\fI^H\fR \fIB\fR)
displays all the buffers, which are always in alphabetical order.  Try that now.
The list is shown in a "pop-up" window.  Press \fI?\fR to see the commands
available in pop-up mode, which are all single keystrokes.  (These are a subset of the ones used by the "less" file
viewer.)  Press \fIq\fR or \fIESC\fR to get back to the edit window.  If you press a key other than a paging command,
it is "remembered" and used as the first keystroke of the next command after the pop-up window is dismissed.
.Sp
Now change some text in both buffers using the \fInextBuf\fR or \fIprevBuf\fR command to switch
between them.  Let's also rename one of the files.  Switch to the "myscript" buffer and type \fI^X\fR \fIF\fR
(\fIsetBufFile\fR).  Enter a new filename of your choosing at the prompt.  When this buffer is next saved, it will be
written to the new file (and if the file already exists, it will be overwritten).
.Sp
It is possible to save the changes in both buffers at once by specifying a numeric prefix (explained below)
to the \fIsaveFile\fR command.  Enter \fI^U\fR \fI^X\fR \fI^S\fR to do this.  Notice that the name of each saved file is
displayed briefly on the message line.
.Sp
Let's open one more file in this editing session, say "src/main.c".
However, we'll have to create the subdirectory first.  To do that, we'll use the \fIshellCmd\fR
command.  Press \fI^X\fR \fI!\fR.  At the "> " prompt, type "mkdir src", then press the space bar to dismiss the
"[End]" prompt.
.Sp
Now we're ready to open our C file, which is done with the \fIfindFile\fR command.  Press \fI^X\fR \fI^F\fR.  At the prompt,
enter "src/main.c".  MightEMacs creates a new empty buffer for the file and switches to
it.  Note that the file has not yet been created
on disk (and if you exited the editor at this point without making any changes to the buffer, it wouldn't be).  Note also
that the mode line now shows the \fIC\fR buffer mode, which enables automatic indentation and fence matching as you type
your C code.
.Sp
Go ahead and enter some code if you wish.  You may also switch to the other buffers and edit those as well
by pressing \fI^X\fR \fI[\fR or \fI^X\fR \fI]\fR as before, or by selecting a buffer directly (by name) with the
\fIselectBuf\fR (\fI^X\fR \fI^B\fR) command.  When you're finished, use the \fIquickExit\fR command again and see that all
the files are saved, and the pathnames are displayed as you return to the shell.
.Sp
Note that MightEMacs can edit text files containing \fICR-LF\fR, \fICR\fR, or \fINL\fR line delimiters.
The line delimiter is determined automatically (by default) when a file is read.  However,
regardless of which delimiter a file contains, all lines in a
buffer are assumed to end with \fICR\fR, which is the character generated by the \fIRETURN\fR key on most keyboards.
MightEMacs remembers the real line delimiter for each buffer and writes it back to disk at the end of each line
when a file is saved.
.SH "KEY BINDINGS"
You have probably noticed that all of the commands we have introduced so far are invoked with either one or two keystrokes
(which may be preceded by a numeric prefix).  As it turns out, this is true for all MightEMacs commands.
No command "binding" is more than two keystrokes.  And if two are required, the first one is always
\fIESC\fR (\fImetaPrefix\fR), \fI^C\fR (\fIcPrefix\fR), \fI^H\fR (\fIhPrefix\fR), or \fI^X\fR (\fIxPrefix\fR).
Additionally, if the second keystroke is a letter, case is ignored.
(A two-key binding is referred to as a "key sequence".)
.Sp
It is also important to know that any key can be bound to a command or macro, including printable characters like letters,
digits, and punctuation characters.  And when you type a key or key sequence, the command or macro that it is bound to is
executed.  By default, the printable keys
are bound to the "self insert" pseudo-command and thus, insert one copy of themselves into the text when typed.
(The one exception to this is the space bar, which is bound to the \fIspace\fR command.)
Non-printable keys and key sequences however, have no default action and will generate an error if typed when not bound
to anything.  Additionally, if an executed key or key sequence returns the value of the \fIfalse\fR
keyword, any running keyboard macro is stopped and "False return" is displayed on the message line.
(Keywords and keyboard macros are discussed later.)
.Sp
Generally, all key bindings used during an editing session are either built-in or are set in startup macros.  You can
change them interactively, however.  To create a key binding, enter \fIESC\fR \fIK\fR (\fIbindKey\fR), and to
delete one, enter \fI^X\fR \fI^K\fR (\fIunbindKey\fR).  To see all commands, macros, aliases,
and bindings, enter \fI^H\fR \fIN\fR
(\fIshowBindings\fR).  Also, see the \fBWRITING SCRIPTS\fR section for the use and syntax of key bindings in coded
string form.
.SH "GETTING HELP"
You may be wondering by now what commands are available and what key(s) invoke them.  MightEMacs provides several ways to
get assistance.  To find out what a particular key or key sequence does, enter
\fI^X\fR \fI?\fR (\fIshowKey\fR).  Try
\fIshowKey\fR now.  Press \fI^X\fR \fI?\fR and at the prompt, type \fI^X\fR \fI^S\fR.  "X-^S saveFile" is
displayed -- the command we used earlier.  Notice however that the key sequence is shown as "X-^S", not "^X-^S".  This is
because the prefix keys can be reassigned, just like any other key, however they always have the same (command) names; that is,
\fImetaPrefix\fR, \fIcPrefix\fR, \fIhPrefix\fR, and \fIxPrefix\fR (which are
\fIESC\fR, \fI^C\fR, \fI^H\fR, and \fI^X\fR by default).  So as a compromise and to help avoid confusion,
key sequences are always displayed (and coded in scripts) with the prefix key as
\fIM\fR, \fIC\fR, \fIH\fR, or \fIX\fR, even if one or more of those keys was changed to another key.
.Sp
MightEMacs also provides informational displays via other "show" commands, which are all bound to a key sequence
that begins with \fI^H\fR.  For example, as was mentioned in the previous section,
to see all commands, macros, aliases, and bindings, press \fI^H\fR \fIN\fR
(\fIshowBindings\fR).  Scroll down to near the bottom of the list and notice that there are a few other "show" commands as well,
which you may want to try.
.Sp
A third way to get help is to use the \fIhelp\fR (\fIESC\fR \fI?\fR) command.
Its default action is to either display a help file (a condensed summary of MightEMacs)
in a pop-up window, or display one of the MightEMacs man files, depending on what you enter at the prompt.  It can be
customized however, to do whatever you want it to do.
.SH "NUMERIC PREFIXES"
Much of the power of MightEMacs comes from the use of a numeric prefix with a command.  (The numeric prefix is
also referred to as the "n argument", mostly when writing scripts.)
A numeric prefix alters the default behavior of a command in some manner,
typically by specifying a direction (backward or forward) and/or a quantity (a number of lines or repetitions,
for example).  To illustrate this, open a file containing a few lines of text and we'll do some navigation.  Press
\fIESC\fR \fIF\fR (\fIforwWord\fR) and notice that the cursor moves one word forward.  Now press \fI^U\fR \fIESC\fR \fIF\fR.
The cursor moves two words forward.  Try \fI^U\fR \fI5\fR \fIESC\fR \fIF\fR or \fI^_\fR \fI^_\fR \fI^N\fR and
see what happens.  You get the idea.
.Sp
To enter a numeric prefix to a command, press \fI^U\fR and/or \fI^_\fR one or more times.  The former key is for positive,
increasing values (in the sequence 2,0,3,4,5,...) and the latter key is for negative, decreasing values
(in the sequence -1,-2,-3,...).  Note that you can generate the negative prefix
by holding down the \fICTRL\fR key and pressing \fI-\fR (dash) with or without the \fISHIFT\fR key.
You may also type digits directly, but only immediately
after the initial numeric prefix key.  Otherwise, the first digit will be taken as a "command" and inserted into the text.
You may also cancel the operation at any time by pressing \fI^G\fR (\fIabort\fR).
.SH "CORE EDITING COMMANDS"
MightEMacs provides a core set of commands for performing common text editing operations in combination with a
numeric prefix.  Once these commands are mastered, you will be able to manipulate text quickly and easily.  The commands
are invoked using the following sequence of keys: (1), an optional numeric prefix; (2), an
optional copy, kill, or delete prefix key; and (3), a text "object" key.
The numeric prefix specifies a direction and quantity (with a default of one item forward).
The prefix key specifies the type of operation: copy (\fI^C\fR for "copy"), kill (\fI^H\fR for "homicide"),
or delete (no prefix).
And finally, the "object" key specifies the type of object to operate on: a word (\fI^\\\fR), partial line (\fI^K\fR),
line (\fI^L\fR), region (\fI^W\fR), or fenced region (\fI{\fR or \fI}\fR).
Copy and kill operations save the target text in the kill ring (for later "yanking"); deletes do not.
.Sp
So for example,
the following keys would kill the current line and the next line: \fI^U\fR \fI^H\fR \fI^L\fR.  This translates
to "for 2 items forward", "kill", "line".  (Note that line operations always include an entire line plus the delimiter,
and the first line is always the current line.)  To \fBdelete\fR two lines forward instead, you would enter: \fI^U\fR \fI^L\fR.
Other examples:
.Sp
.in +.4i
\fI^U\fR \fI3\fR \fI^K\fR
.in +1.5i
.sp -1v
Delete text from the cursor up to, but not including the third line break.
.in
\fI^_\fR \fI^\\\fR
.in +1.5i
.sp -1v
Delete previous word.
.in
\fI^_\fR \fI^C\fR \fI^\\\fR
.in +1.5i
.sp -1v
Copy previous word (without moving the cursor).
.in
\fI^H\fR \fI{\fR
.in +1.5i
.sp -1v
Kill fenced region (cursor must be positioned on a \fI(\fR, \fI)\fR, \fI[\fR, \fI]\fR, \fI{\fR, \fI}\fR, \fI<\fR, or \fI>\fR
character first).
.in
\fI^C\fR \fI^W\fR
.in +1.5i
.sp -1v
Copy region (mark 0 must have been previously set).
.in
\fI^U\fR \fI^U\fR \fI^H\fR \fI^K\fR
.in +1.5i
.sp -1v
Kill text from cursor to beginning of line (zero numeric prefix).
.PP
There is one exception to this rule: the \fIdeleteFencedText\fR command, which is \fI^X\fR \fI{\fR or \fI^X\fR \fI}\fR.
A left or
right brace would be inserted into the text if entered by itself, so the \fI^X\fR prefix (for "exterminate") is needed.
.Sp
Also note that even though delete commands do not save the target text in the kill ring, the text \fBis\fR saved
in a special internal buffer, and the most recently deleted text can always be restored via the
\fIundelete\fR (\fIESC\fR \fIU\fR) command.
.SH "KILL RING"
Whenever a text object is copied or killed, it is saved in the kill ring.  The kill ring is a 30-slot area of memory
which can hold any amount of text in each slot.  When a new kill occurs, previous kills are "pushed back" one position
(in a stack fashion) so that the most recent kill is always the first one to be retrieved.  The \fIyank\fR (\fI^Y\fR)
command is used to insert text from the kill ring into the text, at the current cursor position.
You should try this out and get a good feel for how it works.  It is a very handy feature.
.Sp
There are three other related
commands that you should know as well: \fIyankPop\fR (\fIESC\fR \fIY\fR), \fIcycleKillRing\fR (\fI^X\fR \fIY\fR),
and \fIshowKillRing\fR (\fI^H\fR \fIK\fR).  To yank the most recent kill, press \fI^Y\fR.  If you want a kill before that,
immediately press \fIESC\fR \fIY\fR (\fIyankPop\fR) one or more times.  Each time you execute the
\fIyankPop\fR command, the last inserted kill text
is replaced with the previous one.  It also cycles the kill ring so that the last kill inserted stays at the "top".
.Sp
You can also cycle the kill ring manually before yanking via the \fIcycleKillRing\fR command.
This is handy when you have two or more kills
and want to insert each one in a different place.  Move to the first location and insert the last kill first (\fI^Y\fR),
move to the next location, cycle the kill ring (\fI^X\fR \fIY\fR), then insert the next one (\fI^Y\fR).
.Sp
Another way to do this is to use a negative n argument with \fIyank\fR to access older kills directly.  In the last example,
you could skip the cycle command and insert the next to last kill via \fI^_\fR \fI^Y\fR.
.Sp
Lastly, to see the kill ring at any time (in a pop-up window), enter \fI^H\fR \fIK\fR.  The most recent kill is number
0, followed by -1, -2, etc.
.SH "POP-UP WINDOWS"
By now, you probably have a pretty good idea what pop-up windows are.  They are used extensively
by MightEMacs for many purposes, including "completions" which are explained next.  If you are still a little foggy
about them however, now would be a good time for a review.  You can use the \fIshowBindings\fR (\fI^H\fR \fIN\fR)
command to display a pop-up window and figure out how to move around in it.  Remember that \fI?\fR displays the available
commands and \fIq\fR or \fIESC\fR exits.
.SH "COMPLETIONS"
MightEMacs provides a very useful feature called "completions".  With few exceptions, any time a command, alias, macro,
buffer name, or file pathname needs to be entered at a prompt, you can enter zero or more characters of a name
and press the tab key to see the items that begin with those characters in a pop-up window.  This can be repeated as many
times as you like by adding or subtracting characters and pressing the tab key again.  If only one item matches, then the
name is "completed" when the tab key is pressed and, depending on the operation,
either (1), the entire name is shown, waiting for you to press RETURN to
continue; or (2), the entire name is displayed (very briefly) and the operation is performed automatically.
.Sp
For example, say you want to search for a file to edit.  You can use the \fIfindFile\fR command and look around.
Enter \fI^X\fR \fI^F\fR.  At the prompt, type part of a file path and hit the tab key.  You should see matching filenames
in a pop-up window.  (If nothing matches the
characters you entered however, the window will be blank and you will hear an audible beep.)  You can see all the
files in the current directory by pressing the tab key immediately after the prompt.  You can also expand environmental
variables and your home directory by entering \fI$xxx/\fR and \fI~/\fR respectively.
.SH "MODES"
MightEMacs provides two types of "modes" to activate features during the
editing session: \fBglobal\fR and \fBbuffer\fR.  Global modes apply to all buffers, whereas buffer
modes (as the name implies) apply only to the buffer in which they are activated.  Both types of modes are
displayed in the mode line at the bottom of each window.  Global modes are in parentheses "()" and buffer modes are in
brackets "[]".
.Sp
It is possible to activate a global mode but not display it.  This is controlled
by \fBshow\fR modes.  It is also possible to predefine buffer modes that all new buffers will be initialized with.  These
are the \fBdefault\fR modes.
.Sp
To see all available modes, use the \fIshowVariables\fR command (\fI^H\fR \fIV\fR) and note the names that begin
with "$Mode".  The keyword in parentheses or brackets at the beginning of the description indicates whether
the mode is a global or buffer type, and the digit or capitalized letter in the keyword is the
shortcut character.  (The latter is used interactively to activate, toggle, or deactivate a mode.)  For example,
"$ModeOver [oVer] ..." means that "over" is a buffer mode with a shortcut character of "V".
The shortcut characters are also shown in the second column of the buffer list, which is displayed with
the \fIshowBuffers\fR command (\fI^H\fR \fIB\fR).
.Sp
The four mode commands are
\fIalterGlobalMode\fR (\fIESC\fR \fIM\fR), \fIalterBufMode\fR (\fI^X\fR \fIM\fR),
\fIalterShowMode\fR (\fI^H\fR \fIM\fR), and \fIalterDefMode\fR (\fI^C\fR \fIM\fR).
.SH "BUFFER COMMANDS"
All editing of text occurs in a buffer.  A buffer may or may not be attached to a file.  If it is, the filename will be
shown in the mode line of the window displaying the buffer.
The filename is completely independent of the buffer.  It may be changed at any time or
deleted.  It really only comes into play when an I/O operation is performed on the buffer, at which point it must exist
and be valid for the I/O operation to complete successfully.  As you may have guessed, MightEMacs opens a
file, performs I/O, and closes the file at the moment a file command is executed.  The file is not opened until then and is
closed immediately afterward.
.Sp
The \fIsetBufFile\fR (\fI^X\fR \fIF\fR) command is used to associate a filename with the current buffer.  If you press
\fIRETURN\fR or \fI^K\fR at the prompt, the filename will be deleted.
.Sp
MightEMacs provides several other commands for working with buffers, which you may want to try out:
.Sp
.in +.4i
\fIclearBuf\fR		\fI^X\fR \fI^?
.in\fR +2.5i
.sp -1v
Delete all text from the current buffer and mark as unchanged.
.in
\fIdeleteBuf\fR		\fI^X\fR \fIK\fR
.in +2.5i
.sp -1v
Delete a named buffer.
.in
\fIinsertBuf\fR		\fI^X\fR \fIR\fR
.in +2.5i
.sp -1v
Insert a named buffer into the current buffer.
.in
\fImarkBuf\fR		\fIESC\fR \fI^@\fR
.in +2.5i
.sp -1v
Mark the entire current buffer as the current region (presumably for a subsequent region command).
.in
\fInextBuf\fR		\fI^X\fR \fI]\fR
.in +2.5i
.sp -1v
Switch to the next (alphabetically higher) buffer.
.in
\fIprevBuf\fR		\fI^X\fR \fI[\fR
.in +2.5i
.sp -1v
Switch to the previous (alphabetically lower) buffer.
.in
\fIscratchBuf\fR	\fI^X\fR \fIS\fR
.in +2.5i
.sp -1v
Create a "scratch" buffer with a unique name and switch to it.
.in
\fIselectBuf\fR		\fI^X\fR \fI^B\fR
.in +2.5i
.sp -1v
Switch to a named buffer.
.in
\fIsetBufName\fR	\fI^X\fR \fIB\fR
.in +2.5i
.sp -1v
Set the name of the current buffer (which cannot be null).
.in
\fItruncBuf\fR		\fIESC\fR \fIT\fR
.in +2.5i
.sp -1v
Truncate current buffer; that is, delete all text from the cursor to the end of the buffer.
.in
\fIunchangeBuf\fR	\fIESC\fR \fI~\fR
.in +2.5i
.sp -1v
Mark the current buffer as unchanged.
.in
\fIxeqBuf\fR		\fI^X\fR \fIX\fR
.in +2.5i
.sp -1v
Execute a named buffer as a macro.
.PP
There are two other buffer commands worth mentioning: \fInarrowBuf\fR (\fI^X\fR \fI<\fR) and
\fIwidenBuf\fR (\fI^X\fR \fI>\fR).  The \fInarrowBuf\fR command temporarily shrinks the current buffer to a block of
contiguous lines, which is determined by the numeric prefix.  When buffer "narrowing" is in effect, a "<" character is
displayed in the third column of the mode line.  Narrowing a buffer can be useful for performing editing operations on
a portion of it without affecting the excluded text; for example, when doing a search and replace, or running a keyboard
macro repeatedly until the "end" of the buffer is reached.  A buffer can remain narrowed for as long as you like and
edited normally, although you will not be able to access any of the hidden lines while it is narrowed.  To restore it
(keeping any changes that were made), enter \fI^X\fR \fI>\fR.
.SH "FILE COMMANDS"
In our examples thus far, we have used two file commands: \fIsaveFile\fR and \fIfindFile\fR.  There are a few
other file commands as well.  The file commands provide various ways to read and write files and manage their
associated buffers.  Here is the complete list:
.Sp
.in +.4i
\fIappendFile\fR	\fI^X ^A\fR
.in +2.5i
.sp -1v
Prompt for a filename (waiting for RETURN to be entered when completing the name),
append the current buffer to the given file, and attach the filename to the buffer.
.in
\fIfindFile\fR		\fI^X ^F\fR
.in +2.5i
.sp -1v
Prompt for a filename (waiting for RETURN to be entered when completing the name if the numeric prefix is 1)
and find the file.  Check pathnames associated with existing buffers first, then files on disk.  Switch to the existing buffer
if found; otherwise, create a buffer, switch to it, and read in the file from disk.
.in
\fIinsertFile\fR	\fI^X ^I\fR
.in +2.5i
.sp -1v
Insert a file from disk into the current buffer before the current line.
.in
\fIreadFile\fR		\fI^X ^R\fR
.in +2.5i
.sp -1v
Read a file from disk into the current buffer, replacing its contents, and mark the buffer as unchanged.
.in
\fIsaveFile\fR		\fI^X ^S\fR
.in +2.5i
.sp -1v
Write the current buffer to its associated file, overwriting the file if it already exists.
.in
\fIviewFile\fR		\fI^X ^V\fR
.in +2.5i
.sp -1v
Find a file in the same manner as the findFile command, but enable the 'rdonly' buffer mode also.
.in
\fIwriteFile\fR		\fI^X ^W\fR
.in +2.5i
.sp -1v
Prompt for a filename (waiting for RETURN to be entered when completing the name),
write the current buffer to the given file, and attach the filename to the buffer.
.in
\fIxeqFile\fR		\fIESC\fR \fI/\fR
.in +2.5i
.sp -1v
Execute a file as a macro.
.PP
If an OS error occurs when reading a file, a "#" character is displayed in the first column of the mode line, indicating
that the buffer is in a "truncated" state.  If you subsequently try to save the buffer, you will be warned as such.
.SH "APROPOS"
It is possible to search for names of commands, functions, or variables by using the apropos feature of the
\fIshowBindings\fR (\fI^H\fR \fIN\fR), \fIshowFunctions\fR (\fI^H\fR \fIF\fR), and \fIshowVariables\fR (\fI^H\fR \fIV\fR)
commands.  To perform an apropos search, simply enter a numeric prefix to the command.  You will then be prompted for
a search string.  Any names that contain the string you enter will be displayed (ignoring case).
For example, to find all the "show" commands, enter \fI^_\fR \fI^H\fR \fIN\fR and type "show" at the prompt.  (The numeric
argument must be negative to view the results in a pop-up window.  This is explained in more detail in the BUFFER RENDERING
section below.)
.Sp
You may also use the \fIapropos\fR (\fIESC\fR \fIA\fR) macro, which searches all three "show" lists and displays the results
in a single pop-up window.
.SH "SEARCHING AND REPLACING"
There is a group of commands for searching for a pattern in a buffer and optionally, replacing one or more occurrences of
the matching text with a string or another pattern.  MightEMacs
supports searching using regular expressions (REs) or fixed patterns.  Additionally, either type of search can be
case-sensitive or case-insensitive, and searching can be done either forward or backward.
The type of pattern matching is controlled by two global modes: \fBExact\fR and
\fBRegexp\fR.  When enabled, the former specifies case-sensitive pattern matching and the latter specifies RE matching.
Either or both can be enabled or disabled at any time.
.Sp
The following regular expression metacharacters are supported: \fB^\fR \fB$\fR \fB.\fR \fB*\fR \fB+\fR \fB?\fR \fB[\fR
\fB]\fR \fB(\fR \fB)\fR \fB\\\fR.  The \fB?\fR character is used for
"zero or one of the previous item" or as a modifier following \fB*\fR or \fB+\fR meaning "as few as possible".  Character
classes \fB[]\fR may contain range(s) or be negated with a leading
\fB^\fR metacharacter; for example, "[a-zA-Z0-9_]" or "[^0-9]".
Plain parentheses are used for grouping and escaped versions \fB\\(\fR and \fB\\)\fR are used to search for the literal
characters.  (See the \fIabout\fR command, \fI^H\fR \fIA\fR, for the maximum number of groups.)  Additionally,
a colon and a letter may be appended to any RE to specify an option.  Currently, only one option is supported:
"m" (multi-line mode), which causes the \fB.\fR metacharacter and a negative character class \fB[^...]\fR to match a \fICR\fR,
which they do not by default (but only if, in the latter case, the character class does not contain a \fICR\fR).
The \fI|\fR and \fB{}\fR metacharacters are not currently supported, and closure metacharacters (\fB*\fR \fB+\fR \fB?\fR) may
not be applied to a group.
.Sp
To search for a pattern, use the \fIsearchForw\fR (\fI^S\fR) or \fIsearchBack\fR (\fI^R\fR) command.  You will be prompted
to enter the pattern (which is delimited by \fIESC\fR so that \fICR\fR can be entered as part of the pattern).
Once a pattern has been set (which is saved in the $search variable),
the \fIhuntForw\fR (\fI^]\fR) and \fIhuntBack\fR (\fI^^\fR) commands may be used to search for the next occurrence.
.Sp
To find and replace text, use the \fIreplace\fR (\fIESC\fR \fIR\fR) or \fIqueryReplace\fR (\fIESC\fR \fIQ\fR) command.
To replace a fixed number of occurrences of a pattern, specify a numeric prefix to the \fIreplace\fR command; otherwise,
it will replace all occurrences from the cursor to the end of the buffer.  The \fIqueryReplace\fR command works like
\fIreplace\fR but prompts for an action to take each time a match is found.  (Enter \fI?\fR at the prompt to get a list.)
Actions include: skipping to the next occurrence,
undoing the last replacement and reprompting at that location, stopping and returning to the starting point, and replacing
all remaining matches without prompting.  In all cases, either command will stop if a match is not found.  The replacement
pattern is saved in the $replace variable.
.Sp
There is one additional search and replace option: the \fIqueryReplaceAll\fR macro (\fIESC\fR \fI^Q\fR), which is loaded
from the site startup file "memacs.mm".  This macro performs a \fIqueryReplace\fR on every (visible) buffer in the current
editing session, pausing from one to the next to display results and give you the option to continue or quit.
Additionally, it can be preceded by the \fIgrepFiles\fR macro (\fIESC\fR \fIS\fR, also loaded from
the site startup file), to open all files matching a shell glob pattern, or only those matching the shell pattern and also
containing a fixed (fgrep) or RE (egrep) pattern.  This gives you the ability to find files containing a pattern
and then doing a mass search and replace on those files in real time.  For the \fIgrepFiles\fR macro, use a numeric prefix
to perform an RE search.  You may also leave the search pattern blank (by pressing \fIESC\fR at the prompt) to skip the
"grep" filtering.  Additionally, you may limit the buffers to search to just the ones found by \fIgrepFiles\fR by entering a
negative numeric prefix to the \fIqueryReplaceAll\fR macro.
.SH "LINE WRAPPING"
MightEMacs provides the ability to wrap text, either automatically as you type, or all at once by
specifying a block of lines to operate on.  There are three commands
for this: \fIwrapWord\fR, \fIwrapLine\fR (\fIESC\fR \fI^W\fR), and \fIjoinLines\fR (\fIESC\fR \fI^\fR).
.Sp
By default, the \fIwrapWord\fR command is used as the "wrap hook" and has no key binding.  It is called by the editor when
the "wrap" buffer mode is enabled and other conditions are met (see \fBHOOKS\fR below for more information).
The command moves the word at or just before the cursor to a new
line if possible, and deletes any white space that preceded it.  However, if no space character is found preceding the word,
it moves the cursor to the end of the line (by default) and starts a new line.  This behavior can be modified somewhat by
specifying a numeric prefix, which it uses as the left margin column instead of 0 (the default).  In this case,
it will only wrap words that are wholly at or beyond the left margin, and if no space character is found preceding the word,
it will search forward for a space character and break the line at that point if possible, instead of at the end of the line.
.Sp
The \fIwrapWord\fR command is intended to only be used indirectly, either by enabling the "wrap" buffer mode as mentioned
previously, or by executing the \fIwrapLine\fR command which rewraps a block of lines.
The latter command, which is the second method for wrapping text, is in the "line" family and uses the
numeric prefix accordingly to identify a block of one or more lines to operate on.  When invoked,
it saves any indentation (white space) from the first line of the block, calls
\fIjoinLines\fR to convert the block to a single line by changing all embedded line breaks and surrounding white space to a
single space, then rewraps the line at the wrap column ($wrapCol) repeatedly,
inserting the indentation before each new line, until the remainder is too short to wrap any further.  The command calls the
\fIwrapWord\fR command with a numeric prefix equal to the end-of-indentation column to achieve this.
.Sp
Additionally, two options are available for line wrapping when these commands are called from a script.
\fIjoinLines\fR takes a \fInil\fR or string argument, the latter of which is a
list of characters to be considered the "end of a sentence".  When the command joins two lines, it will insert an extra space
if the first line ends with one of the specified characters and the second line is not blank or all white space.  The value
of the string argument is typically ".?!"; however, it can also be a null string to prevent this "extra space" behavior.
If the argument is \fInil\fR instead, the command will join lines with no space between them.
.Sp
The second available option is for the \fIwrapLine\fR command, which takes two arguments: a line "prefix",
and an end-of-sentence
string to pass to \fIjoinLines\fR.  The line prefix is a string that will be inserted after any indentation in each line
that is created during the wrapping process; for example, "# " or "// " to specify a comment in various
programming languages.  Existing prefix strings (with or without trailing white space)
are also recognized and removed from each line of the block
before \fIjoinLines\fR is called.  See the \fIbfFormatItem\fR macro in memacs-macros(1) for an example of this usage.
.SH "WINDOWS"
When working with multiple buffers (or files), it is often useful to split the screen into two or more windows and display
the buffers in separate windows.  This is accomplished with the \fIsplitWind\fR (\fI^X\fR \fI2\fR) command, which splits
the current window into two windows of equal size.
Initially, the same buffer is attached to both windows, which can be useful for
displaying different portions of the same buffer.  To display a different buffer in one of the windows, we use one of the same
commands we used before: \fInextBuf\fR, \fIprevBuf\fR, or \fIselectBuf\fR.
The entire process may then be repeated to create additional windows.
.Sp
The next obvious question is, "How do we adjust the sizes of each window?".  There are three commands for this:
\fIresizeWind\fR (\fI^X\fR \fIW\fR), \fIgrowWind\fR (\fI^X\fR \fI+\fR), and \fIshrinkWind\fR (\fI^X\fR \fI-\fR).
These commands set, increase, or decrease the current window size by the number of rows specified with the numeric prefix.
.Sp
And likewise, there are commands for deleting windows as well: \fIdeleteWind\fR (\fI^X\fR \fI0\fR) deletes the
current window, \fIjoinWind\fR (\fI^X\fR \fIJ\fR) joins the current window with the window below it (by default),
and \fIonlyWind\fR (\fI^X\fR \fI1\fR) deletes all windows except the current one.  All the window commands can be
more finely controlled with a numeric prefix.  See the \fIshowBindings\fR command descriptions for details.
.Sp
To switch to another window, use \fInextWind\fR (\fI^X\fR \fIN\fR) or \fIprevWind\fR (\fI^X\fR \fIP\fR).  There are numeric
prefix options for these two commands as well.
.SH "BUFFER RENDERING"
As explained in the previous section, you can create multiple windows in MightEMacs, which is especially useful for working
with multiple buffers.  It can be tedious however, to set up the windows the way you want them.
MightEMacs provides some help with this by employing the following convention.  Mostly all buffer
and file commands may be given a numeric prefix in the range -2 to +3,
which controls the disposition or "rendering" of its buffer after the command completes.  The values of the numeric
prefix and their actions are:
.Sp
.in +.4i
< -1 
.in +1.5i
.sp -1v
Display buffer in a pop-up window with a basic mode line containing the buffer name and filename,
and delete the buffer afterward if it was just created.
.in
-1
.in +1.5i
.sp -1v
Same as < -1, except keep the existing mode line.
.in
0
.in +1.5i
.sp -1v
Leave the buffer as is (normally in the background).
.in
1
.in +1.5i
.sp -1v
Select the buffer; that is, attach and display it in the current window (the default action).
.in
2
.in +1.5i
.sp -1v
Display the buffer in another window, creating one if necessary.
.in
> 2
.in +1.5i
.sp -1v
Same as 2, except also switch to that window.
.PP
These numeric prefixes take a little while to learn and get used to, but they can definitely give you better control of your
editing sessions.  Here are some examples:
.Sp
.in +.4i
\fI^U\fR \fI3\fR \fI^X\fR \fI^F\fR
.in +1.5i
.sp -1v
Find a file, display it in a new window, and switch to it.
.in
\fI^_\fR \fI^X\fR \fI^R\fR
.in +1.5i
.sp -1v
Display the on-disk version of a file in a pop-up window (whether or not it is currently being edited).
.in
\fI^_\fR \fI^X\fR \fI^F\fR
.in +1.5i
.sp -1v
Display a file in a pop-up window, using any existing buffer attached to that file (instead of the on-disk version)
if it exists.
.in
\fI^U\fR \fI^X\fR \fI^B\fR
.in +1.5i
.sp -1v
Select a buffer (creating it if necessary) and display it in another window.
.in
\fI^U\fR \fI^U\fR \fI^X\fR \fI^F\fR
.in +1.5i
.sp -1v
Find a file, but don't select its buffer (to be edited later).
.SH "SCREENS"
In addition to windows, MightEMacs provides the option of creating multiple screens to manage buffers.
A screen is the entire display, containing all visible windows.  Multiple screens directly overlap each other (so only
one may be viewed at a time) and are numbered, beginning at 1.  If multiple screens exist, the number of the current
(frontmost) one is displayed in the mode line of the bottom-most window.
.Sp
Let's try this out.  Type the following command again to start the editor:
.Sp
.in +.4i
\&$ mm Notes.txt myscript.mm
.PP
At startup (usually), the first file is displayed in a single window on screen number 1.
Enter \fI^X\fR \fI2\fR to create another window,
then press \fI^V\fR to move the cursor so the windows have different "looks" (on the same buffer).  Now press
\fIESC\fR \fI^S\fR (\fInewScreen\fR) and observe that a second screen is created with just one window, and the
window's mode line now
contains "S2", identifying the screen.  Press \fI^X\fR \fI]\fR so that screen 2 is displaying a different buffer than screen 1.
And then use \fInextScreen\fR (\fIESC\fR \fI]\fR) or \fIprevScreen\fR (\fIESC\fR \fI[\fR) to switch back to screen 1.
Notice that the first screen looks exactly as it did before.
This technique is very useful for keeping your places in various windows and buffers and quickly switching among them.
You can create as many screens as you like.
.Sp
The complete list of screen commands follows:
.Sp
.in +.4i
\fInewScreen\fR		\fIESC ^S\fR
.in +2.5i
.sp -1v
Create a new screen, assign the next available sequential number as its identifier, and switch to it.
.in
\fIdeleteScreen\fR	\fIESC ^D\fR
.in +2.5i
.sp -1v
Delete the screen specified by the numeric prefix (which must be in the background)
and renumber any other higher-numbered screens to "fill the hole".
.in
\fInextScreen\fR	\fIESC ]\fR
.in +2.5i
.sp -1v
Switch to the next (sequentially higher numbered) screen.
.in
\fIprevScreen\fR	\fIESC [\fR
.in +2.5i
.sp -1v
Switch to the previous (sequentially lower numbered) screen.
.in
\fIredrawScreen\fR	\fIESC L\fR
.in +2.5i
.sp -1v
Redraw the current screen and (usually) relocate the current line according to the numeric prefix.
.in
\fIshowScreens\fR	\fI^H S\fR
.in +2.5i
.sp -1v
Display a list of all screens with their window numbers, buffer names, and filenames in a pop-up window.
An asterisk (*) is shown before the buffer name if the buffer has been modified.
.PP
See the individual command descriptions in the \fIshowBindings\fR display for more details.
.SH "KEYBOARD MACROS"
You may find during an editing session that you need to perform the same series of commands on multiple lines or
portions of text.  MightEMacs has the ability to save (or record) keystrokes in memory (a "keyboard macro")
and then play them back as many
times as you like, as if you had entered them by hand.
.Sp
The general method of recording and playing back a keyboard macro is as follows:
.Sp
.in +.4i
1.
.in +.3i
.sp -1v
Position the cursor at the beginning of the first text object (typically, the beginning of a line).
.in
2.
.in +.3i
.sp -1v
Start recording by entering \fI^X\fR \fI(\fR (\fIbeginKeyMacro\fR).
.in
3.
.in +.3i
.sp -1v
Enter commands to change the first text object to the desired form and position the cursor at the
beginning of the next object when done.
.in
4.
.in +.3i
.sp -1v
Stop recording by entering \fI^X\fR \fI)\fR (\fIendKeyMacro\fR).
.in
5.
.in +.3i
.sp -1v
Play back
the keyboard macro you just recorded for each of the remaining text objects by entering a numeric prefix followed by
\fI^X\fR \fIE\fR (\fIxeqKeyMacro\fR).
.PP
For example, say you have the following lines of text and wish to convert them to an
initializer for an array variable for a C program you're working on:
.Sp
.in 1.1i
blue,32,The sky
.in 1.1i
green,7,Grass blades
.in 1.1i
red,1,Hot chile peppers
.in 1.1i
yellow,15,Ripe bananas
.PP
One way to do this is to position the cursor at the beginning of the first line (at the "b" of "blue"), then use the
following series of keys:
.Sp
.in +.4i
\fI^X\fR \fI(\fR \fI{\fR \fI^U\fR \fI^S\fR \fI,\fR \fIESC\fR \fI"\fR \fI^E\fR \fI"\fR \fI}\fR \fI,\fR
\fI^F\fR \fI^X\fR \fI)\fR
.PP
This sequence does the following: begins a keyboard macro, inserts a left brace, searches for the second comma, inserts a double
quote character, moves to the end of line, inserts a double quote, a right brace,
and a comma, moves forward one character (to the beginning
of the next line), and ends recording.  Now it can be played back three times by isuing \fI^U\fR \fI3\fR \fI^X\fR \fIE\fR,
which produces the following result:
.Sp
.in 1.1i
{blue,32,"The sky"},
.in 1.1i
{green,7,"Grass blades"},
.in 1.1i
{red,1,"Hot chile peppers"},
.in 1.1i
{yellow,15,"Ripe bananas"},
.PP
This can definitely save you a lot of typing, especially when you have many similar text objects to edit.
You can also use the \fIseti\fR (\fI^X\fR \fII\fR) command to initialize the editor's internal "i" variable and the
\fIinserti\fR (\fIESC\fR \fI^I\fR) command in a keyboard macro to insert a series of numbers (ascending or descending),
optionally with associated text; for example,
to number (or renumber) a group of lines.  See the descriptions in the \fIshowBindings\fR display for the syntax.
You may want to experiment with this and see how it works.
.SH "WRITING SCRIPTS"
MightEMacs supports a simple yet powerful scripting language.  It allows you for example, to write your own "commands"
(or "macros" in Emacs terminology) which provides a means of extending the editor's features and capabilities to suit
your needs.  The language uses a C-like syntax for expressions, single-line statements, and optional "directives"
for looping, conditional execution, and defining macros, among other things.  
A macro that is defined in a script operates identically to a built-in command; that is, it accepts a numeric
prefix, can be bound to a key (and invoked interactively), and can be called from a script with arguments.
.Sp
Scripts are written in buffers or files and then executed with
the \fIxeqBuf\fR (\fI^X\fR \fIX\fR) or \fIxeqFile\fR (\fIESC\fR \fI/\fR) commands.  Script files may also be executed
from the command line when starting the editor or from another script (for example, from the "memacs.mm" site startup file).
.Sp
You can try this out for yourself in the editor.  Create a scratch buffer and enter the following lines:
.Sp
.in +0.4i
# Example script that defines a macro which accepts two arguments.
.sp +0v
!macro example,2
.in +0.4i
print "Base name of file '#{$1}' is '#{-1 => basename $1}'"
.sp +0v
$2
.in
!endmacro
.PP
.Sp
Execute the buffer by entering \fI^X\fR \fIX\fR and typing the name of the scratch buffer at the prompt.  Macro
\fIexample\fR is now defined.  (You can verify this via the \fIshowBindings\fR command.  You should see "@example" near the
bottom of the list with no key binding.)
.Sp
Now let's execute the macro and capture it's return value in a global variable.  Type \fIESC\fR \fI^X\fR (\fIeval\fR)
to execute a command line.  At the prompt, enter
"$result = example '/dir1/myfile.txt',77" and press RETURN, which will run the macro.
You should see "Base name of file '/dir1/myfile.txt' is 'myfile'" in the message
line.  Now check the global variable.  Enter \fI^H\fR \fIV\fR \fIG\fR and observe that variable $result has a value of 77.
.Sp
This was admittedly a contrived example of writing a script and a macro, but does illustrate the basics of how it's done.
For something more practical, consider the following.  Say you are testing a script and want to clear all hooks at the
beginning of it so that they will not be invoked when your script is run.
This script snippet accomplishes that by getting a list of all hook variables into a buffer,
looping through them, setting each one to null by building an assignment statement that is executed with the \fIeval\fR
command, then deleting the temporary buffer:
.Sp
.in +0.4i
# Clear all hooks.
.sp +0v
bufName = 0 => showVariables 'hook'
.sp +0v
!until nil?(line = readBuf bufName)
.in +0.4i
null?(line) || eval shift(line,nil),' = ""'
.in
!endloop
.sp +0v
1 => deleteBuf bufName
.PP
.Sp
As you can see, useful work can be done with just a few lines of code.
.Sp
Note in the first example
that a macro was defined with a pair of directives: \fI!macro\fR and \fI!endmacro\fR.  All directives begin with an
exclamation point (!), must be the first symbol on a line (optionally preceded by white space), and must have white space
between their names and their argument(s), if any.
Following is a list of all directives and their usage:
.Sp
.in +0.4i
\fI!macro\fR \fIname\fR[,\fIarg-count\fR]
.in +2.7i
.sp -1v
Define a macro.  If the \fIarg-count\fR expression is specified, it must evaluate to a non-negative integer and
the macro must be called with that exact number of arguments or an error will occur.  If \fIarg-count\fR is not specified,
the macro may be called with any number of arguments (including none).
.in
\fI!endmacro\fR
.in +2.7i
.sp -1v
End the definition of the most recent macro being defined, which is determined by locating the most recent
unpaired !macro directive.  (Macro definitions
may be nested; that is, a macro can define a macro when it is executed.)
.in
\fI!if\fR \fIcomma-expr\fR
.in +2.7i
.sp -1v
Begin an "if" statement.  The condition is true if the last expression of \fIcomma-expr\fR evaluates to true.
.in
\fI!elsif\fR \fIcomma-expr\fR
.in +2.7i
.sp -1v
Specify an "else if" statement for the most recent unpaired !if directive.  The condition
is true if the last expression of \fIcomma-expr\fR evaluates to true and
the paired !if and any prior !elsif directives that follow the !if were false.
Zero or more !elsif directives may follow an !if.
.in
\fI!else\fR
.in +2.7i
.sp -1v
Specify an "else" statement, which is true if the paired !if and any !elsif directives that follow the !if were false.
Zero or one !else directives may follow an !if.
.in
\fI!endif\fR
.in +2.7i
.sp -1v
End an "if" statement, which is determined by locating the most recent unpaired !if directive.
.in
\fI!while\fR \fIcomma-expr\fR
.in +2.7i
.sp -1v
Begin a "while" statement.  The block of statements following the directive to its paired !endloop is
executed while its condition is true (zero or more times).
.in
\fI!until\fR \fIcomma-expr\fR
.in +2.7i
.sp -1v
Begin an "until" statement.  The block of statements following the directive to its paired !endloop is
executed until its condition is true (zero or more times).
.in
\fI!loop\fR
.in +2.7i
.sp -1v
Begin a "loop" statement.  The block of statements following the directive to its paired !endloop is
executed an indefinite number of times (one or more).
The block must contain at least one !break or !return directive to prevent an endless do loop.
.in
\fI!endloop\fR
.in +2.7i
.sp -1v
End a "while", "until", or "loop" statement, which is determined by locating the most recent unpaired
!while, !until, or !loop directive.
.in
\fI!break\fR [\fIcomma-expr\fR]
.in +2.7i
.sp -1v
Break out of one (the default) or more enclosing loop blocks, determined by \fIcomma-expr\fR (if specified),
the last expression of which must evaluate to
an integer greater than zero.  Control is transferred to the end of the last block that is exited.
.in
\fI!return\fR [\fIcomma-expr\fR]
.in +2.7i
.sp -1v
Exit a macro or executing buffer and return to the caller.  The return value is the last expression of \fIcomma-expr\fR
if specified; otherwise, \fInil\fR.
.in
\fI!force\fR \fIcomma-expr\fR
.in +2.7i
.sp -1v
Force the successful evaluation of \fIcomma-expr\fR; that is, ignore any error which may occur when it is evaluated.
.PP
It is also possible to create an alias of a command or macro with the \fIalias\fR (\fI^C\fR \fI^A\fR) command.  An alias
has the same functionality as a command or macro, except that it cannot be bound to a key.
.Sp
When writing scripts, note the following:
.in +.4i
.Bb
A script consists of zero or more lines.  Blank lines and lines that begin with \fI#\fR as the first non-whitespace character
(a comment) are ignored.  Comments may also occur at the end of a line.  All remaining lines or portions of lines
are interpreted as statements.
.Le
.Bb
A statement consists of an optional directive followed by an optional \fIcomma-expr\fR, which is a series of one or
more expressions separated by commas.
.Le
.Bb
Expressions are either string or integer types and with few exceptions, are not automatically converted from one type to the
other when expressions are evaluated (like in the Perl language, for example).
You can use the \fItoInt\fR and \fItoString\fR functions for this purpose.
There is also a pseudo (string) type for keywords \fItrue\fR, \fIfalse\fR, and \fInil\fR, the latter of which represents a
"nothing" value and is different from a null string.  Additionally, the \fIdefn\fR keyword exists, which holds an integer value
equal to the default n argument.
.Le
.Bb
String literals are defined with single quotes (\fI'\fR) or double quotes (\fI"\fR).  Integers may be coded in any form which
is permitted by the strtol() function of the Standard C Library where the base is zero.
.Le
.Bb
A single-quoted string may contain \fI\\'\fR or
\fI\\\\\fR to specify an apostrophe or backslash character.  All other characters are taken literally.
.Le
.Bb
A double-quoted string may contain \fI\\"\fR, \fI\\\\\fR, \fI\\x\fR, \fI\\num\fR or \fI#{comma-expr}\fR to specify a
double quote character, a backslash character, a special control character designated by the letter \fIx\fR,
an octal or hexadecimal value of a character, or an interpolated expression.  The \fI\\x\fR control characters and
their octal values are:
.in +0.4i
.sp
\fI\\r\fR	015	Carriage return
.sp +0v
\fI\\n\fR	012	Newline
.sp +0v
\fI\\t\fR	011	Tab
.sp +0v
\fI\\b\fR	010	Backspace
.sp +0v
\fI\\f\fR	014	Form feed
.sp +0v
\fI\\e\fR	033	Escape
.in -0.4i
.sp
To specify the octal or hexadecimal value of an ASCII character,
use \fI\\0nnn\fR (zero to three digits after the zero) or \fI\\0xnn\fR (one or two hexadecimal digits after the "x",
leading zero is optional).
.Sp
The result of an arbitrary expression may also be inserted into the string by using \fI#{comma-expr}\fR, where
\fIcomma-expr\fR may itself contain a double-quoted string with an interpolated expression (nesting is allowed).
.in -0.4i
.Bb
\fI0\fR, \fIfalse\fR, \fInil\fR, and null strings (\fI''\fR and \fI""\fR) are false;
all other expressions and variable values are true.
.Le
.Bb
There are two types of variables: global and local.  Global variables begin with a dollar sign (\fI$\fR), have global
scope, and are permanent.  Local variables do not have a leading dollar sign,
are accessible only within the script or macro in which they are
created (assigned to), and are deleted when the script or macro exits.  Predefined global variables whose names begin with
a capital letter (for example, $LineLen) are read-only and thus, cannot be assigned to.
.Le
.Bb
A command, alias, function, or macro may be called with zero or more argument(s) separated by commas, and may also be
called with an n argument.
An n argument is passed via the binary operator \fI=>\fR using the syntax
\fIint-expr\fR \fI=>\fR \fIname\fR, where \fIint-expr\fR is the n argument and \fIname\fR
is the command, alias, function, or macro name.  The \fI=>\fR operator has high precedence in an expression.  (See
file "Syntax.txt" for a description of all directives, expressions, operators, and their precedences.)
.Le
.Bb
A buffer containing a script may be executed just like a macro
by using the \fIxeqBuf\fR command.  The command essentially acts as a "macro proxy" and is called
with an optional n argument and a comma-separated list of arguments, the first of which must evaluate
to the name of the buffer to execute.  The n argument (if any) and all arguments after the first are passed to the script.
.Le
.Bb
A command, alias, function, or macro that is called with argument(s) may be coded
with or without parentheses around the argument list;
that is, in form "\fIname\fR(\fIarg1\fR,\fIarg2\fR,...)" or "\fIname\fR \fIarg1\fR,\fIarg2\fR,...".  However, be
aware that the latter form is more prone to ambiguity and may induce a syntax error.  If parentheses are used, there must not
be any white space between the function name and the left \fI(\fR parenthesis; otherwise, it will be
interpreted as an unparenthesized function call (the second form) with the first argument in parentheses.
The first form is also used to specify zero arguments, as in "\fIname\fR()".  The parentheses may be required in
this case to prevent tokens that follow \fIname\fR from being interpreted as its arguments.
.Le
.Bb
The n argument is accessed from a macro or executing buffer via the $0 variable.  Other arguments
are accessed via the $1, $2, ... variables.
All $\fIn\fR variables may be assigned to, although $0 must be an integer value.
.Le
.Bb
All scripts and macros are invoked as functions and return a value, which is the result of the last expression statement
evaluated or the value of a !return directive.
.Le
.Bb
Return messages (which are different from return \fBvalues\fR) are generated by certain commands and by using the
\fInotice\fR function in a script or macro.  While a script is
executing, the most recent return message is available in the $ReturnMsg variable.  A message from a command (like
\fIsetMark\fR or \fIcopyLine\fR) has low priority and will not replace an existing message.  The \fInotice\fR function however,
has high priority and will always replace an existing message.  The disposition of a message is also dependent on the current
state of the "msg" global mode.  If message mode is off, command messages are not saved, but \fInotice\fR messages
still are.  When control is eventually returned to the user, the final saved message (if any) is displayed
on the message line.  Note that if a script writes a message directly to the message
line (via the \fIprint\fR function), it will be overwritten by any return message and thus may not be seen,
depending on script execution time.  The \fIpause\fR function can be used in this case as a workaround.
.Le
.Bb
The \fIbinding\fR function and the \fIbindKey\fR and \fIunbindKey\fR commands take a key binding as their first argument.  Key
bindings are specified in a coded string form beginning with zero or more of the following:
.Sp
.in +.4i
\fIM-\fR
.in +.8i
.sp -1v
Meta prefix key.
.in
\fIC-\fR
.in +.8i
.sp -1v
C prefix key.
.in
\fIH-\fR
.in +.8i
.sp -1v
H prefix key.
.in
\fIX-\fR
.in +.8i
.sp -1v
X prefix key.
.in
\fIS-\fR
.in +.8i
.sp -1v
Shifted (function) key.
.in
\fIFN\fR
.in +.8i
.sp -1v
Function key.
.in
\fI^\fR
.in +.8i
.sp -1v
Control key.
.in
.in -.4i
.sp
which is followed by a printable character to complete the sequence, with no intervening space.
Additionally, \fISPC\fR (in upper or lower case) may be specified for a space character.  Some examples are:
.Sp
.in +.4i
\fBKey(s)\fR
.in +3.6i
.sp -1v
\fBCoded string form\fR
.in
.sp
\fI^F\fR
.in +3.6i
.sp -1v
\'^F\' (or \'^f\')
.in
\fIESC\fR
.in +3.6i
.sp -1v
\'^[\'
.in
\fIRETURN\fR
.in +3.6i
.sp -1v
\'^M\'
.in
Right arrow
.in +3.6i
.sp -1v
\'FNF\'
.in
Shift left arrow
.in +3.6i
.sp -1v
\'S-FNB\'
.in
\fI^X\fR followed by \fIK\fR
.in +3.6i
.sp -1v
\'X-K\'
.in
\fIESC\fR followed by \fIESC\fR
.in +3.6i
.sp -1v
\'M-^[\'
.in
The carat key \fI^\fR
.in +3.6i
.sp -1v
\'^\'
.in
\fI^H\fR followed by carat \fI^\fR
.in +3.6i
.sp -1v
\'H-^\'
.in
Control carat
.in +3.6i
.sp -1v
\'^^\'
.in
Control space (null character)
.in +3.6i
.sp -1v
\'^@\'
.in
Delete key
.in +3.6i
.sp -1v
\'^?\'
.in
\fIESC\fR followed by control space
.in +3.6i
.sp -1v
\'M-^@\'
.in
\fIESC\fR followed by space
.in +3.6i
.sp -1v
\'M- \' or \'M-SPC\'
.in
The letter \fIQ\fR
.in +3.6i
.sp -1v
\'Q\' or \'S-q\' or \'S-Q\'
.in
.in -.4i
.sp
Coded strings are not case-sensitive, with the exception of a single-letter binding (like 'f'), which is.  Consequently,
\'h-F\' is the same key sequence as \'H-f\', but \'x\' is different than \'X\'.  Also, raw 7-bit characters greater than
zero may also be specified for any control character and the delete key,
so the pairs \'^A\' and "\\1", \'^M\' and "\\r", and \'C-^?\' and "c-\\x7f" are the same.
.Le
.PP
See the \fIshowBindings\fR, \fIshowFunctions\fR, and \fIshowVariables\fR listings for descriptions of all the
commands, functions, and variables which are available for use in a script.
.Sp
Lastly, note that all commands (and macros) return \fInil\fR by default.  The following commands however, have different
return values:
.Sp
.in 1.1i
\fBCommand\fR
.in +1.8i
.sp -1v
\fBReturn value\fR
.Sp
.in 1.1i
\fIappendFile\fR
.in +1.8i
.sp -1v
Filename.
.in 1.1i
\fIalterBufMode\fR
.sp 0v
\fIalterDefMode\fR
.sp 0v
\fIalterGlobalMode\fR
.sp 0v
\fIalterShowMode\fR
.in +1.8i
.sp -1v
Former state (-1 or 1) of last mode altered.  (The value can be used as the n argument of a subsequent command to
restore the former state of that mode.)
.in 1.1i
\fIbackChar\fR
.sp 0v
\fIbackLine\fR
.in +1.8i
.sp -1v
\fIfalse\fR if hit a buffer boundary; otherwise, \fItrue\fR.
.in 1.1i
\fIclearBuf\fR
.in +1.8i
.sp -1v
\fIfalse\fR if buffer is not cleared; otherwise, \fItrue\fR.
.in 1.1i
\fIdeleteBuf\fR
.in +1.8i
.sp -1v
Name of last buffer deleted (last command argument).
.in 1.1i
\fIeval\fR
.in +1.8i
.sp -1v
Result of evaluation.
.in 1.1i
\fIfindFile\fR
.in +1.8i
.sp -1v
Name of buffer, a tab character, and \fItrue\fR or \fIfalse\fR indicating whether the buffer was created.
.in 1.1i
\fIforwChar\fR
.sp 0v
\fIforwLine\fR
.in +1.8i
.sp -1v
\fIfalse\fR if hit a buffer boundary; otherwise, \fItrue\fR.
.in 1.1i
\fIhideBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIhuntBack\fR
.sp 0v
\fIhuntForw\fR
.in +1.8i
.sp -1v
String found, or \fIfalse\fR if not found.
.in 1.1i
\fIinsertFile\fR
.in +1.8i
.sp -1v
Filename.
.in 1.1i
\fIinsertPipe\fR
.in +1.8i
.sp -1v
\fIfalse\fR if failure; otherwise, \fItrue\fR.
.in 1.1i
\fInewScreen\fR
.in +1.8i
.sp -1v
New screen number.
.in 1.1i
\fInextBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fInextScreen\fR
.in +1.8i
.sp -1v
New screen number.
.in 1.1i
\fIpipeBuf\fR
.in +1.8i
.sp -1v
\fIfalse\fR if failure; otherwise, \fItrue\fR.
.in 1.1i
\fIprevBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIprevScreen\fR
.in +1.8i
.sp -1v
New screen number.
.in 1.1i
\fIqueryReplace\fR
.in +1.8i
.sp -1v
\fIfalse\fR if search stopped prematurely; otherwise, \fItrue\fR.
.in 1.1i
\fIreadFile\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIreadPipe\fR
.in +1.8i
.sp -1v
Name of buffer, or \fIfalse\fR if failure.
.in 1.1i
\fIrun\fR
.in +1.8i
.sp -1v
Execution result.
.in 1.1i
\fIscratchBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIsearchBack\fR
.sp 0v
\fIsearchForw\fR
.in +1.8i
.sp -1v
String found, or \fIfalse\fR if not found.
.in 1.1i
\fIselectBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIsetBufFile\fR
.in +1.8i
.sp -1v
New filename.
.in 1.1i
\fIsetBufName\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIshell\fR
.sp 0v
\fIshellCmd\fR
.in +1.8i
.sp -1v
\fIfalse\fR if failure; otherwise, \fItrue\fR.
.in 1.1i
\fItruncBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIunbindKey\fR
.in +1.8i
.sp -1v
Boolean result if n > 0; otherwise, \fInil\fR.
.in 1.1i
\fIunchangeBuf\fR
.sp 0v
\fIunhideBuf\fR
.in +1.8i
.sp -1v
Name of buffer.
.in 1.1i
\fIviewFile\fR
.in +1.8i
.sp -1v
Name of buffer, a tab character, and \fItrue\fR or \fIfalse\fR indicating whether the buffer was created.
.in 1.1i
\fIwriteFile\fR
.in +1.8i
.sp -1v
Filename.
.in 1.1i
\fIxeqBuf\fR
.sp 0v
\fIxeqFile\fR
.in +1.8i
.sp -1v
Execution result.
.SH "USER INPUT"
It is possible to get user input from a script by using the \fIprompt\fR function, which displays a prompt on the message
line, reads a response, and returns the result.  When using the function, note the following:
.in +.4i
.Bb
It accepts one to four arguments in the following order:
.Sp
.in +.4i
1.
.in +.3i
.sp -1v
A prompt string.
.in
2.
.in +.3i
.sp -1v
A default value.
.in
3.
.in +.3i
.sp -1v
An input delimiter, specified in the same format as a key binding.
.in
4.
.in +.3i
.sp -1v
A prompt type, specified as a single-character string.
.in
.in -.4i
.sp
The first argument is required; all other arguments are optional.  However, no arguments may be skipped.
.Le
.PP
.in +.4i
.Bb
If a default value is specified (including a null string), it is displayed after the prompt string between square
brackets \fI[ ]\fR and is returned as the function result if the user enters just the delimiter key.  The default value may
also be specified as \fInil\fR for none (the default).
If there is no default value and the user enters just the delimiter key, the function returns \fInil\fR.  If on the other
hand, the user presses \fI^K\fR, the function returns a null string instead.
.Le
.Bb
The input delimiter may be specified as \fInil\fR or '^M' to
use the default (the \fIRETURN\fR key), or a different key (for example, \fIESC\fR, coded as \'^[\') so that
\fIRETURN\fR can be entered as part of the input string.
.Le
.Bb
The last argument provides input options and is specified as one of five letters:
.Sp
.in +.4i
\fIb\fR
.in +1.1i
.sp -1v
Enable buffer name completion during input.
.in
\fIc\fR
.in +1.1i
.sp -1v
Read a single character (one keystroke) and return it.
.in
\fIf\fR or \fIF\fR
.in +1.1i
.sp -1v
Enable filename completion during input.  If \fIF\fR is specified, wait for the delimiter to be entered before returning.
.in
\fIs\fR
.in +1.1i
.sp -1v
Read a string without completion (the default).
.Le
.SH "HOOKS"
Certain operations during an editing session may be controlled or customized by assigning the name of a command or
macro to a "hook" variable.  Operations include switching buffers, reading or writing a file, and executing keys.
When a hook is triggered, the command or macro associated with the hook is called with arguments, if applicable (see below).
If an error occurs during execution or the command or macro returns false (that is, the value of the
\fIfalse\fR keyword), an error message is displayed and the hook is disabled.
.Sp
Note that you can assign a command to a hook, but it usually makes no sense to do so.  The one exception is the "wrap" hook
which is set to the \fIwrapWord\fR command by default.  The \fIwrapWord\fR command is designed just for this purpose.
.Sp
The complete list of hooks follows:
.Sp
.in 1.1i
\fBVariable\fR
.in +1.6i
.sp -1v
\fBMacro arguments\fR
.in +2.0i
.sp -1v
\fBDescription\fR
.Sp
.in 1.1i
$exitBufHook
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Exit-buffer hook -- called just before leaving a buffer.  $bufName is the name of the buffer being exited.
.in 1.1i
$enterBufHook
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Enter-buffer hook -- called after switching to another buffer.  $bufName is the name of the buffer being entered.
.in 1.1i
$helpHook
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Help hook -- called when the \fIhelp\fR command is executed.
.in 1.1i
$modeHook
.in +1.6i
.sp -1v
$globalModes,
 $showModes,
 $defBufModes,
 $bufModes
.in +2.0i
.sp -4v
Mode-change hook -- called whenever any mode is changed.  Arguments are the prior variable values.  (Each argument value
can be compared to the current value of the same variable to find the one that was changed.)
.in 1.1i
$preKeyHook
.in +1.6i
.sp -1v
Entered key
.in +2.0i
.sp -1v
Pre-key hook -- called after a key sequence is entered, but before it is executed.  The hook macro may set a new key to be
executed by assigning one to the $lastKeySeq variable.  It may also prevent the current key from being executed by
returning a true value.
.in 1.1i
$postKeyHook
.in +1.6i
.sp -1v
Entered key
.in +2.0i
.sp -1v
Post-key hook -- called immediately after a key sequence is executed (or skipped if the pre-key hook returned true).
The argument is the same one given to the pre-key hook.  $lastKeySeq will (usually) contain the key that was
actually executed.
.in 1.1i
$readHook
.in +1.6i
.sp -1v
Buffer name,
 filename
.in +2.0i
.sp -2v
Read-file hook -- called after a file is read into a buffer.  The second (filename)
argument will be \fInil\fR if standard input was read.
.in 1.1i
$writeHook
.in +1.6i
.sp -1v
Buffer name,
 filename
.in +2.0i
.sp -2v
Write-file hook -- called just before a file is written to disk.
.Sp
.in 1.1i
$wrapHook
.in +1.6i
.sp -1v
(none)
.in +2.0i
.sp -1v
Wrap-word hook -- called when the "wrap" buffer mode is enabled, the "rdonly" buffer mode is disabled,
a space or return was entered, and the cursor is at or past the wrap column ($wrapCol).
.SH "TERMINAL DIMENSIONS"
Part of MightEMacs's startup processing is to map its screen to the size of the terminal window.  It can also do this
during an editing session if the size of the terminal window changes; for example, when changing the orientation of a
smart phone from portrait to landscape or vice-versa.  To update the screen dimensions, use
the \fIresetTerm\fR (\fIESC\fR \fIESC\fR) command.
.SH "SEE ALSO"
memacs(1), memacs-macros(1)
